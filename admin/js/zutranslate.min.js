(function () {
	'use strict';

	// WordPress dependencies
	// const { map, has } = lodash;
	var __$1 = wp.i18n.__; // Zukit dependencies

	var simpleMarkdown$1 = wp.zukit.utils.simpleMarkdown;
	var externalDataSettings = wp.zukit.render.externalDataSettings; // Settings page strings and assets

	var _externalDataSettings = externalDataSettings('zutranslate', {}),
	    pluginInacive = _externalDataSettings.disabled,
	    qtxUrl = _externalDataSettings.qtxlink; // 'The plugin extend functionality of qTranslate-XT plugin.'
	// 'Customization & settings for Language Switcher.'


	var inacive$1 = __$1('This plugin only *complements* the functionality of the **qTranslate-XT** plugin.\nThe [qTranslate-XT]($link1) version `3.10 or above` should be installed and activated (now it **was not found** among active plugins).', 'zu-translate');

	var options = {
	  gutenberg: {
	    label: __$1('Support WordPress Block Editor', 'zu-translate'),
	    help: __$1('Settings and list of supported blocks see below in the "**Block Editor Support**" section.', 'zu-translate')
	  },
	  flags: {
	    label: __$1('Show flags in buttons', 'zu-translate'),
	    help: __$1('Display country flag on language switching buttons in admin mode.', 'zu-translate')
	  },
	  media_details: {
	    label: __$1('Language Switcher in Media Details', 'zu-translate'),
	    help: __$1('When activated you will not be able to edit the fields when viewing the modal dialog, only on `Edit Media` page.', 'zu-translate')
	  } // NOTE: not yet restored after refactoring
	  // yseo: {
	  // 	label: 	__('Include additional support for Yoast SEO Plugin?', 'zu-translate'),
	  // 	help:	__('The Yoast SEO should be installed and activated.', 'zu-translate'),
	  // },

	}; // NOTE: not yet restored after refactoring

	var switcher = {
	  ls_frontend: {
	    label: __$1('Swither on Front-End?', 'zu-translate'),
	    help: __$1('???', 'zu-translate')
	  },
	  ls_menu: {
	    label: __$1('Swither in Menu?', 'zu-translate'),
	    help: __$1('The switcher should be added in menu to be displayed.', 'zu-translate')
	  },
	  ls_display: {
	    // [
	    // 	'lang' 	=> 'Language Name',
	    // 	'code' 	=> 'Language Code',
	    // ],
	    label: __$1('Display in Menu', 'zu-translate'),
	    help: __$1('How the language will be dispayed in menu', 'zu-translate')
	  } // custom_css: {
	  // 	label: 	__('Use plugin CSS?', 'zu-translate'),
	  // 	help:	__('If switched off the plugin stylesheet won\'t be loaded.', 'zu-translate'),
	  // },

	};
	var gutenberg$1 = {
	  note: __$1('Only blocks **known to this plugin** will support language switching in the **Block Editor**.\nTo disable the block support - turn off the **checkbox** in front of the block name. You can also add other blocks - for this you need to know the **internal** name of the block (which includes the `namespace`) and the name of the attribute/attributes that contain the **content** of the block (*what requires translation*). You can learn these names by looking at the source code of the plugin/themes where these blocks are defined or by contacting the developer.\nUnfortunately, a *simpler* method has not yet been found.', 'zu-translate'),
	  blockTitle: __$1('Supported blocks', 'zu-translate'),
	  compress: __$1('Compress language data to reduce page size', 'zu-translate'),
	  sync: {
	    label: __$1('Synchronize language switching', 'zu-translate'),
	    help: __$1('Switching a language in one block will lead to language switching in all editable blocks.', 'zu-translate')
	  },
	  custom: {
	    nameLabel: __$1('Block name', 'zu-translate'),
	    nameHelp: __$1('The block name must contain a **namespace** and a **slash**, for example, `core/quote`', 'zu-translate'),
	    attsLabel: __$1('Attribute names', 'zu-translate'),
	    attsInput: __$1('Enter the name of the attribute', 'zu-translate'),
	    attsInputHelp: __$1('Usually the attribute has the name `content`, but it is not always so (see note above)', 'zu-translate'),
	    addBlock: __$1('Add block', 'zu-translate')
	  },
	  resetAll: __$1('Reset Block Editor Settings', 'zu-translate'),
	  errName: __$1('It does not look like a valid **block name**. Maybe you forgot the `namespace`? ', 'zu-translate'),
	  errAtts: __$1('You need to specify at least one **attribute** for translation.', 'zu-translate'),
	  errDups: __$1('Duplicates are not allowed. Are you mistaken in the name of the block?', 'zu-translate')
	};
	var panels = {
	  gutenberg: {
	    value: true,
	    label: __$1('Block Editor Support', 'zu-translate'),
	    // Это позволит исключить эту панель когда значение option is false
	    depends: 'gutenberg'
	  },
	  switcher: {
	    value: false,
	    label: __$1('Language Switcher', 'zu-translate')
	  }
	};
	var zutranslate = {
	  options: options,
	  panels: panels,
	  switcher: switcher,
	  gutenberg: gutenberg$1,
	  inacive: pluginInacive ? simpleMarkdown$1(inacive$1, {
	    br: true,
	    links: qtxUrl
	  }) : false
	};

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);

	    if (enumerableOnly) {
	      symbols = symbols.filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	      });
	    }

	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

	  if (_i == null) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;

	  var _s, _e;

	  try {
	    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	// WordPress dependencies
	var _lodash = lodash,
	    get = _lodash.get,
	    map = _lodash.map,
	    isEmpty = _lodash.isEmpty,
	    mapKeys = _lodash.mapKeys,
	    castArray = _lodash.castArray,
	    join = _lodash.join,
	    split = _lodash.split,
	    compact = _lodash.compact,
	    includes = _lodash.includes,
	    without = _lodash.without,
	    omit = _lodash.omit,
	    keys = _lodash.keys,
	    has = _lodash.has;
	var __ = wp.i18n.__;
	var _wp$components = wp.components,
	    Button = _wp$components.Button,
	    CheckboxControl = _wp$components.CheckboxControl,
	    ToggleControl = _wp$components.ToggleControl;
	var _wp$element = wp.element,
	    useCallback = _wp$element.useCallback,
	    useState = _wp$element.useState; // Zukit dependencies

	var _wp$zukit$components$1 = wp.zukit.components,
	    ZukitDivider$1 = _wp$zukit$components$1.ZukitDivider,
	    ZukitPanel$1 = _wp$zukit$components$1.ZukitPanel,
	    AdvTextControl = _wp$zukit$components$1.AdvTextControl,
	    ListInputControl = _wp$zukit$components$1.ListInputControl;
	var _wp$zukit$utils = wp.zukit.utils,
	    simpleMarkdown = _wp$zukit$utils.simpleMarkdown,
	    getExternalData = _wp$zukit$utils.getExternalData,
	    messageWithError = _wp$zukit$utils.messageWithError;
	var scrollTop = wp.zukit.jq.scrollTop;
	var blockEditorKey = 'blockeditor';
	var supported = getExternalData('supported', {});

	function contentAtts(atts) {
	  var comment = __('Content attributes:', 'zu-translate');

	  return simpleMarkdown("".concat(comment, "`").concat(join(castArray(atts), '` `'), "`"));
	}

	function testCustomBlock(name, blockAtts, customBlocks) {
	  var nameRegex = /^(?!\d)[\w$]+\/(?!\d)[\w$]+$/;
	  var atts = compact(split(blockAtts, ','));
	  var error = nameRegex.test(name) ? null : {
	    msg: 'errName',
	    value: isEmpty(name) ? null : name
	  };
	  if (error === null && has(customBlocks, name)) error = {
	    msg: 'errDups',
	    value: name
	  };
	  if (error === null && atts.length === 0) error = {
	    msg: 'errAtts',
	    value: null
	  };
	  return {
	    name: name,
	    atts: atts,
	    error: error
	  };
	}

	var ZutranslateBlockEditor = function ZutranslateBlockEditor(_ref) {
	  var data = _ref.data,
	      options = _ref.options,
	      updateOptions = _ref.updateOptions,
	      resetOptions = _ref.resetOptions,
	      ajaxAction = _ref.ajaxAction,
	      noticeOperations = _ref.noticeOperations;
	  var createNotice = noticeOperations.createNotice;
	  var blockEditorOps = get(options, blockEditorKey, {});
	  var excludedBlocks = get(blockEditorOps, 'excluded', []);
	  var sync = blockEditorOps.sync,
	      excluded = blockEditorOps.excluded,
	      customBlocks = blockEditorOps.supported;

	  var _useState = useState(''),
	      _useState2 = _slicedToArray(_useState, 2),
	      customName = _useState2[0],
	      setCustomName = _useState2[1];

	  var _useState3 = useState(''),
	      _useState4 = _slicedToArray(_useState3, 2),
	      customAtts = _useState4[0],
	      setCustomAtts = _useState4[1];

	  var _useState5 = useState(supported),
	      _useState6 = _slicedToArray(_useState5, 2),
	      supportedBlocks = _useState6[0],
	      setSupportedBlocks = _useState6[1];

	  var resetBEOptions = useCallback(function () {
	    resetOptions(blockEditorKey, function () {
	      return ajaxAction('zutranslate_reset_supported', function (blocks) {
	        setSupportedBlocks(blocks);
	        scrollTop();
	      });
	    });
	  }, [resetOptions, ajaxAction]);
	  var updateBEOptions = useCallback(function (update) {
	    var folderUpdate = mapKeys(update, function (_, key) {
	      return "".concat(blockEditorKey, ".").concat(key);
	    });
	    updateOptions(folderUpdate);
	  }, [updateOptions]);
	  var excludeBlock = useCallback(function (checked, block) {
	    if (checked) updateBEOptions({
	      excluded: without(excluded, block)
	    });else updateBEOptions({
	      excluded: [].concat(_toConsumableArray(excluded), [block])
	    });
	  }, [excluded, updateBEOptions]);
	  var addBlock = useCallback(function () {
	    var _testCustomBlock = testCustomBlock(customName, customAtts, customBlocks),
	        name = _testCustomBlock.name,
	        atts = _testCustomBlock.atts,
	        error = _testCustomBlock.error;

	    if (error === null) {
	      updateBEOptions({
	        supported: _objectSpread2(_objectSpread2({}, customBlocks), {}, _defineProperty({}, name, {
	          name: name,
	          atts: atts
	        }))
	      });
	      setCustomName('');
	      setCustomAtts('');
	    } else {
	      // Can be one of: success, info, warning, error
	      createNotice({
	        status: 'warning',
	        content: messageWithError(data[error.msg], error.value),
	        isDismissible: true,
	        __unstableHTML: true
	      });
	      scrollTop();
	    }
	  }, [customBlocks, customName, customAtts, updateBEOptions, createNotice, data]);
	  var standardBlocks = omit(supportedBlocks, keys(customBlocks));
	  var hasCustomBlocks = !isEmpty(customBlocks);
	  return /*#__PURE__*/React.createElement(ZukitPanel$1, {
	    id: "gutenberg",
	    options: options,
	    initialOpen: true
	  }, /*#__PURE__*/React.createElement(ToggleControl, {
	    label: data.sync.label,
	    help: simpleMarkdown(data.sync.help, {
	      br: true
	    }),
	    checked: sync,
	    onChange: function onChange() {
	      return updateBEOptions({
	        sync: !sync
	      });
	    }
	  }), /*#__PURE__*/React.createElement("h3", {
	    className: "__subtitle"
	  }, data.blockTitle), /*#__PURE__*/React.createElement("div", {
	    className: "__supported"
	  }, map(standardBlocks, function (_ref2, key) {
	    var name = _ref2.name,
	        atts = _ref2.atts;
	    return /*#__PURE__*/React.createElement(CheckboxControl, {
	      key: key,
	      label: name,
	      help: contentAtts(atts),
	      checked: !includes(excludedBlocks, key),
	      onChange: function onChange(value) {
	        return excludeBlock(value, key);
	      }
	    });
	  })), hasCustomBlocks && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ZukitDivider$1, {
	    bottomHalf: true,
	    size: 2
	  }), /*#__PURE__*/React.createElement("div", {
	    className: "__supported"
	  }, map(customBlocks, function (_ref3, key) {
	    var name = _ref3.name,
	        atts = _ref3.atts;
	    return /*#__PURE__*/React.createElement(CheckboxControl, {
	      key: key,
	      label: name,
	      help: contentAtts(atts),
	      checked: !includes(excludedBlocks, key),
	      onChange: function onChange(value) {
	        return excludeBlock(value, key);
	      }
	    });
	  }))), /*#__PURE__*/React.createElement("div", {
	    className: "__note"
	  }, simpleMarkdown(data.note, {
	    br: true
	  })), /*#__PURE__*/React.createElement("div", {
	    className: "__custom"
	  }, /*#__PURE__*/React.createElement(AdvTextControl, {
	    isSideBySide: true,
	    label: data.custom.nameLabel,
	    help: simpleMarkdown(data.custom.nameHelp, {
	      br: true
	    }),
	    value: customName,
	    onChange: setCustomName,
	    onKeyEnter: addBlock
	  }), /*#__PURE__*/React.createElement(ListInputControl, {
	    isOpen: true,
	    isNotEmptyLabel: true,
	    isSideBySide: true,
	    strict: /^(?!\d)[\w$]+$/,
	    label: data.custom.attsLabel,
	    inputLabel: simpleMarkdown(data.custom.attsInput, {
	      br: true
	    }),
	    inputHelp: simpleMarkdown(data.custom.attsInputHelp, {
	      br: true
	    }),
	    value: customAtts,
	    onChange: setCustomAtts
	  }), /*#__PURE__*/React.createElement(Button, {
	    isSecondary: true,
	    className: "__plugin_actions __auto green",
	    label: data.custom.addBlock,
	    icon: "plus-alt",
	    onClick: addBlock
	  }, data.custom.addBlock)), /*#__PURE__*/React.createElement("div", {
	    className: "__flex __right"
	  }, /*#__PURE__*/React.createElement(Button, {
	    isSecondary: true,
	    className: "__plugin_actions __auto magenta",
	    label: data.resetAll,
	    icon: "image-rotate",
	    onClick: resetBEOptions
	  }, data.resetAll)));
	};

	// WordPress dependencies
	// const { isFunction } = lodash;
	// const { useCallback } = wp.element;
	// Zukit dependencies
	var _wp$zukit$render = wp.zukit.render,
	    renderPage = _wp$zukit$render.renderPage,
	    toggleOption = _wp$zukit$render.toggleOption;
	var _wp$zukit$components = wp.zukit.components,
	    ZukitPanel = _wp$zukit$components.ZukitPanel,
	    ZukitDivider = _wp$zukit$components.ZukitDivider; // Internal dependencies
	var optionsData = zutranslate.options,
	    gutenberg = zutranslate.gutenberg,
	    inacive = zutranslate.inacive; // switcher,

	var ZutranslateEdit = function ZutranslateEdit(_ref) {
	  var title = _ref.title,
	      options = _ref.options,
	      updateOptions = _ref.updateOptions,
	      resetOptions = _ref.resetOptions,
	      ajaxAction = _ref.ajaxAction,
	      noticeOperations = _ref.noticeOperations;

	  // const onNotifyChange = useCallback(value => {
	  // 	updateOptions({ notify: value })
	  // }, [updateOptions]);
	  if (inacive) {
	    return /*#__PURE__*/React.createElement("div", {
	      className: "__note"
	    }, inacive);
	  }

	  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ZukitPanel, {
	    title: title
	  }, toggleOption(optionsData, options, updateOptions), /*#__PURE__*/React.createElement(ZukitDivider, null)), /*#__PURE__*/React.createElement(ZutranslateBlockEditor, {
	    data: gutenberg,
	    options: options,
	    updateOptions: updateOptions,
	    resetOptions: resetOptions,
	    noticeOperations: noticeOperations,
	    ajaxAction: ajaxAction
	  }));
	};

	renderPage('zutranslate', {
	  edit: ZutranslateEdit,
	  panels: zutranslate.panels
	});

})();
//# sourceMappingURL=zutranslate.min.js.map
