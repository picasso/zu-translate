(function () {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /**
   * Utilities for qTranslate blocks
   */
  // 	lang_code_format: '[a-z]{2,3}',
  // 	language_config: {
  // 		en: {
  // 			admin_name: "Американский Английский",
  // 			flag: "gb.png",
  // 			locale: "en_US",
  // 			locale_html: "en",
  // 			name: "English",
  // 		},
  // 		ru: {
  // 			admin_name: "Русский",
  // 			flag: "ru.png",
  // 			locale: "ru_RU",
  // 			locale_html: "ru",
  // 			name: "Русский",
  // 		},
  // 	},
  // };

  /* global qTranslateConfig */

  var qtranxj_get_split_blocks = function qtranxj_get_split_blocks(text) {
    var regex = '(<!--:lang-->|<!--:-->|\\[:lang]|\\[:]|{:lang}|{:})'.replace(/lang/g, qTranslateConfig.lang_code_format);
    var splitRegex = new RegExp(regex, "gi"); // Most browsers support RegExp.prototype[@@split]()... except IE

    if ('a~b'.split(/(~)/).length === 3) {
      return text.split(splitRegex);
    } // compatibility for unsupported engines


    var start = 0,
        arr = [];
    var result;

    while ((result = splitRegex.exec(text)) != null) {
      arr.push(text.slice(start, result.index));
      if (result.length > 1) arr.push(result[1]);
      start = splitRegex.lastIndex;
    }

    if (start < text.length) arr.push(text.slice(start));
    if (start === text.length) arr.push(''); // delimiter at the end

    return arr;
  };
  var qtranxj_split = function qtranxj_split(text) {
    var blocks = qtranxj_get_split_blocks(text);
    return qtranxj_split_blocks(blocks);
  };
  var qtranxj_split_blocks = function qtranxj_split_blocks(blocks) {
    var result = new Object();

    for (var _lang in qTranslateConfig.language_config) {
      result[_lang] = '';
    }

    if (!blocks || !blocks.length) return result;

    if (blocks.length === 1) {
      // no language separator found, enter it to all languages
      var b = blocks[0];

      for (var _lang2 in qTranslateConfig.language_config) {
        result[_lang2] += b;
      }

      return result;
    }

    var clang_regex = new RegExp('<!--:(lang)-->'.replace(/lang/g, qTranslateConfig.lang_code_format), 'gi');
    var blang_regex = new RegExp('\\[:(lang)]'.replace(/lang/g, qTranslateConfig.lang_code_format), 'gi');
    var slang_regex = new RegExp('{:(lang)}'.replace(/lang/g, qTranslateConfig.lang_code_format), 'gi');
    var lang = false;
    var matches;

    for (var i = 0; i < blocks.length; ++i) {
      var _b = blocks[i];
      if (!_b.length) continue;
      matches = clang_regex.exec(_b);
      clang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      matches = blang_regex.exec(_b);
      blang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      matches = slang_regex.exec(_b);
      slang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      if (_b === '<!--:-->' || _b === '[:]' || _b === '{:}') {
        lang = false;
        continue;
      }

      if (lang) {
        if (!result[lang]) result[lang] = _b;else result[lang] += _b;
        lang = false;
      } else {
        // keep neutral text
        for (var key in result) {
          result[key] += _b;
        }
      }
    }

    return result;
  };

  // WordPress dependencies
  var _ = lodash; // Zukit dependencies

  var _wp$zukit$utils = wp.zukit.utils,
      externalData = _wp$zukit$utils.externalData,
      getExternalData = _wp$zukit$utils.getExternalData;
      _wp$zukit$utils.toJSON;
      _wp$zukit$utils.simpleMarkdown;
      _wp$zukit$utils.getColorOptions; // Import debug object and make it available from global scope
  window.Zubug = _objectSpread2({}, wp.zukit.debug || {}); // Internal dependencies
  externalData('zutranslate_blocks_data'); // перед вызовами 'getExternalData' нужно один раз вызвать 'externalData'

  var supportedData = getExternalData('supported', {});
  var delimiters = ['[]', '{}', '<!-- -->']; // const blockName = 'core/paragraph';

  var supportedBlocks = _.keys(supportedData); // const blockDel = splitInHalf(delimiters[0]);


  function getTranslatedAtts(name) {
    return _.castArray(_.get(supportedData, [name, 'atts']));
  }
  function getTranslatedValues(name, attributes) {
    var translatedKeys = getTranslatedAtts(name);

    var translatedAtts = _.pick(attributes, translatedKeys);

    return [_.join(translatedKeys, ','), _.values(translatedAtts)];
  }
  function hasRaw(ref) {
    var _ref$current;

    return !!(ref !== null && ref !== void 0 && (_ref$current = ref.current) !== null && _ref$current !== void 0 && _ref$current.raw);
  }
  function isSupported(name) {
    return _.includes(supportedBlocks, name);
  }
  function hasTranslations(text) {
    var blocks = qtranxj_get_split_blocks(text !== null && text !== void 0 ? text : ''); // no language separator found - there are no translations

    return (blocks === null || blocks === void 0 ? void 0 : blocks.length) > 1; // if (!blocks || !blocks.length)
    // 	return result;
    // if (blocks.length === 1) {
  }
  function getLangContent(raw, lang) {
    var _blocks$lang;

    var blocks = _.isArray(raw) ? qtranxj_split_blocks(raw) : getTranslatedBlocks(raw);
    return (_blocks$lang = blocks[lang]) !== null && _blocks$lang !== void 0 ? _blocks$lang : '';
  }
  function createRawContent(lang, values, translatedAtts) {
    if (values) {
      var separator = marker(testDelimters(), null, null, true);

      var rawItems = _.fill(_.range(0, values.length), '');

      var prevRaw = _.reduce(values, function (foundRaw, value) {
        return foundRaw === false ? hasTranslations(value) ? value : false : foundRaw;
      }, false);

      if (prevRaw) {
        var index = _.indexOf(values, prevRaw);

        var atts = _.split(translatedAtts !== null && translatedAtts !== void 0 ? translatedAtts : '', ',');

        _.set(rawItems, index, prevRaw);

        return [_.join(rawItems, separator), _defineProperty({}, atts[index], getLangContent(prevRaw, lang))];
      }

      var raw = _.join(rawItems, separator);

      return [updateRawContent(raw, lang, values), {}];
    }

    return [null, {}];
  }
  function updateRawContent(raw, lang) {
    var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (values) {
      var del = testDelimters(raw);
      var separator = marker(del, null, null, true);

      var content = _.split(raw, separator);

      var rawItems = _.reduce(content, function (newRaw, rawItem, index) {
        var blocks = getTranslatedBlocks(rawItem);

        if (values[index] !== undefined) {
          blocks[lang] = values[index];

          var withMarkers = _.map(blocks, function (text, ln) {
            return marker(del, ln, text);
          });

          newRaw[index] = _.join([].concat(_toConsumableArray(withMarkers), [marker(del)]), '');
        }

        return newRaw;
      }, []);
      return _.join(rawItems, separator);
    }

    return raw;
  }
  function switchContent(raw, lang, translatedAtts) {
    var atts = _.split(translatedAtts, ',');

    var rawItems = splitRawContent(raw);
    return _.reduce(atts, function (attributes, attr, index) {
      var value = getLangContent(rawItems[index], lang);

      _.set(attributes, attr, value);
      return attributes;
    }, {}); // setAttributes({
    //     qtxLang: rawRef.current.lang,
    //     content: getLangContent(rawRef.current.raw, rawRef.current.lang),
    // });
  }

  function splitRawContent(raw) {
    var del = testDelimters(raw);
    var separator = marker(del, null, null, true);
    return _.split(raw, separator);
  }

  function getTranslatedBlocks(raw) {
    return qtranxj_split(raw !== null && raw !== void 0 ? raw : '');
  }

  function splitInHalf(s) {
    var str = String(s);
    var middle = Math.floor(str.length / 2);
    return [str.substr(0, middle).trim(), str.substr(middle).trim()];
  }

  function testDelimters(s) {
    var blockDel = splitInHalf(delimiters[0]);

    if (_.isString(s)) {
      _.forEach(delimiters, function (d) {
        var del = splitInHalf(d);
        var regex = new RegExp(marker(del), 'gi');

        if (regex.exec(s) !== null) {
          blockDel = del;
          return false;
        }
      });
    }

    return blockDel;
  }

  function marker(del) {
    var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var split = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return "".concat(del[0]).concat(split ? ',' : ':').concat(lang !== null && lang !== void 0 ? lang : '').concat(del[1]).concat(text !== null && text !== void 0 ? text : '');
  }

  var _window$qTranslateCon;

  // WordPress dependencies
  var _lodash$1 = lodash,
      map = _lodash$1.map; // Internal dependencies
  // import { getColorOptions, getExternalData } from './utils.js';

  var _ref = (_window$qTranslateCon = window.qTranslateConfig) !== null && _window$qTranslateCon !== void 0 ? _window$qTranslateCon : {},
      config = _ref.language_config; // creates Quote Colors Object
  // const quoteColors = getColorOptions({},
  // 	[{ slug: 'opacity', color: 'transparent', name: 'Semi-Transparent'}],
  // 	['none']
  // );


  function transformLangValue(value, label, style) {
    return /*#__PURE__*/React.createElement("span", {
      className: "__lang",
      style: style
    }, label);
  }
  var assets = {
    langOptions: map(config, function (data, key) {
      return {
        value: key,
        label: data.name
      };
    }) // [{ value: 'block', label: 'Block' }, { value: 'line', label: 'Line' }],
    // colors: quoteColors,

  }; // export default assets;

  // WordPress dependencies
  // const { pick, isNil, assign } = lodash;
  var __ = wp.i18n.__; // const { addFilter } = wp.hooks;

  var createHigherOrderComponent = wp.compose.createHigherOrderComponent;
  var PanelBody = wp.components.PanelBody;
  var InspectorControls = wp.blockEditor.InspectorControls;
  var _wp$element = wp.element,
      useEffect = _wp$element.useEffect,
      useCallback = _wp$element.useCallback,
      useRef = _wp$element.useRef; // cloneElement, useState, useEffect, useLayoutEffect
  // const { select, subscribe } = wp.data; //
  // Zukit dependencies

  var SelectItemControl = wp.zukit.components.SelectItemControl; // const { useRefInit } = wp.zukit.data;

  var rawPrefix = 'components-zu-raw-edit';
  var withRawEditControls = createHigherOrderComponent(function (BlockEdit) {
    return function (props) {
      var name = props.name,
          isSelected = props.isSelected,
          setAttributes = props.setAttributes,
          attributes = props.attributes;
      var qtxRaw = attributes.qtxRaw,
          _attributes$qtxLang = attributes.qtxLang,
          qtxLang = _attributes$qtxLang === void 0 ? 'en' : _attributes$qtxLang; // Zubug.useMU();

      var rawRef = useRef(null);

      if (rawRef.current === null) {
        rawRef.current = {
          lang: qtxLang,
          raw: qtxRaw
        };
        Zubug.data({
          lang: qtxLang,
          raw: qtxRaw
        }, 'Raw loaded');
      }

      var _getTranslatedValues = getTranslatedValues(name, attributes),
          _getTranslatedValues2 = _slicedToArray(_getTranslatedValues, 2),
          translatedAtts = _getTranslatedValues2[0],
          translatedValues = _getTranslatedValues2[1]; // конвертировать content в рав если требуется при маунтинг


      useEffect(function () {
        if (!hasRaw(rawRef)) {
          var _createRawContent = createRawContent(qtxLang, translatedValues, translatedAtts),
              _createRawContent2 = _slicedToArray(_createRawContent, 2),
              raw = _createRawContent2[0],
              update = _createRawContent2[1];

          rawRef.current.raw = raw;
          setAttributes(_objectSpread2({
            qtxLang: qtxLang,
            qtxRaw: raw
          }, update));
          Zubug.data({
            lang: qtxLang,
            raw: raw,
            update: update
          }, 'Raw created');
        } // we used a spread element in the dependency array -> we can't statically verify the correct dependencies
        // eslint-disable-next-line react-hooks/exhaustive-deps

      }, []); // After each change in one of the attributes that require the translation, we update 'qtxRaw'

      useEffect(function () {
        // Zubug.info('attributes changed', translatedValues, rawRef);
        if (hasRaw(rawRef)) {
          var _rawRef$current = rawRef.current,
              raw = _rawRef$current.raw,
              lang = _rawRef$current.lang;
          var updatedRaw = updateRawContent(raw, lang, translatedValues);

          if (updatedRaw !== rawRef.current.raw) {
            rawRef.current.raw = updatedRaw;
            setAttributes({
              qtxRaw: updatedRaw
            });
            Zubug.data({
              updatedRaw: updatedRaw
            }, 'Raw updated');
          }
        } // we used a spread element in the dependency array -> we can't statically verify the correct dependencies
        // eslint-disable-next-line react-hooks/exhaustive-deps

      }, [].concat(_toConsumableArray(translatedValues), [setAttributes])); // Replace the values of all 'translated' attributes for the required language

      var replaceContent = useCallback(function (lang) {
        var raw = rawRef.current.raw; // const lang = qtxLang === 'en' ? 'ru' : 'en';

        var atts = switchContent(raw, lang, translatedAtts);
        rawRef.current.lang = lang;
        setAttributes(_objectSpread2({
          qtxLang: lang
        }, atts));
      }, [translatedAtts, setAttributes]);
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(BlockEdit, props), isSelected && isSupported(name) && /*#__PURE__*/React.createElement(InspectorControls, null, /*#__PURE__*/React.createElement(PanelBody, {
        title: __('Language')
      }, /*#__PURE__*/React.createElement(SelectItemControl, {
        className: rawPrefix,
        withLabels: true,
        options: assets.langOptions,
        selectedItem: qtxLang,
        onClick: replaceContent,
        transformValue: transformLangValue
      }))));
    };
  }, 'withRawEditControls'); // <ToggleControl

  // WordPress dependencies
  var _lodash = lodash,
      isNil = _lodash.isNil,
      assign = _lodash.assign; // const { __ } = wp.i18n;

  var addFilter = wp.hooks.addFilter; // const { useEffect, useCallback } = wp.element; // cloneElement, useState, useEffect, useLayoutEffect

  var _wp$data = wp.data,
      select = _wp$data.select,
      subscribe = _wp$data.subscribe; //

  function addRawAttribute(settings, name) {
    if (!isNil(settings.attributes)) {
      if (isSupported(name)) {
        // Zubug.data({ settings });
        settings.attributes = assign({}, settings.attributes, {
          qtxRaw: {
            type: 'string'
          },
          qtxLang: {
            type: 'string'
          }
        });
      }
    }

    return settings;
  }

  addFilter('blocks.registerBlockType', 'zu/paragraph', addRawAttribute);
  addFilter('editor.BlockEdit', 'zu/paragraph', withRawEditControls); // NOTE: All experiments left here --------------------------------------------]

  var _select = select('core/editor'),
      isSavingPost = _select.isSavingPost;

  var postSaved = true;
  subscribe(function () {
    if (isSavingPost()) {
      postSaved = false;
      Zubug.info('{isSavingPost}');
    } else {
      if (!postSaved) {
        Zubug.info('~Post Saved~');
        postSaved = true;
      }
    }
  }); // function applyExtraProps(extraProps, blockType, attributes) {
  // 	const {
  // 		content,
  // 		rawContent,
  // 		lang,
  // 	} = attributes;
  // 	if(isSupported(blockType?.name)) {
  // 		Zubug.data({ extraProps, blockType, attributes });
  // 	}
  //
  // 	const blocks = qtranxj_split(rawContent);
  // 	blocks[lang] = content;
  // 	const newLang = lang === 'en' ? 'ru' : 'en';
  // 	Zubug.data({ lang, content,  blocks });
  // 	extraProps.className join([...map(blocks, (text, l) => `[:${l}]${text}`), '[:]'], '')
  //
  // 	if(typeof hideOnMobile !== 'undefined' && hideOnMobile) {
  // 		extraProps.className = extraProps.className + ' hide-on-mobile';
  // 	}
  // 	return extraProps;
  // }
  // addFilter('blocks.getSaveContent.extraProps', 'zu/paragraph', applyExtraProps);
  // function getBlockAttributes(attributes, blockType, param3, param4) {
  // 	if(isSupported(blockType?.name)) {
  // 		const { content, rawContent, lang } = attributes;
  // 		const translated = rawContent ? getLangContent(rawContent, lang) : content;
  // 		attributes.content = translated;
  // 		Zubug.data({ attributes, blockType, param3, param4 });
  // 		return attributes;
  // 	}
  // 	return attributes;
  // }
  // addFilter('blocks.getBlockAttributes', 'zu/paragraph', getBlockAttributes);
  // function getSaveElement(elem, blockType, attributes) {
  // 	const blockName = blockType?.name;
  // 	if(isSupported(blockName)) {
  // 		// Zubug.info('called');
  // 		if(attributes.isXT) {
  // 			// const fallback = () => elem;
  // 			const { rawContent } = attributes;
  // 			const isEdit = !!rawContent;
  // 			// // const save = get(blockSave, blockName) ?? fallback;
  // 			Zubug.info(isSavingPost() ? '{isSavingPost}' : 'update?');
  // 			if(isEdit) {
  // 				attributes.content = rawContent;
  // 				// attributes.rawContent = undefined;
  // 				const newEl = cloneElement(elem, { attributes });
  // 				Zubug.data({ content: attributes.content, rawContent: attributes.rawContent }, 'new Element');
  // 				return newEl;
  // 			}
  // 		}
  // 	}
  // 	return elem;
  // }
  // addFilter('blocks.getSaveElement', 'zu/paragraph', getSaveElement);

})();
//# sourceMappingURL=zutranslate-blocks.min.js.map
