var zutranslate_blocks = (function (exports) {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // WordPress dependencies
  var __ = wp.i18n.__; // className,
  // name,
  // title,
  // icon,
  // slot     kind of SlotFills which will be used:
  //              'setting'       - PluginDocumentSettingPanel
  //              'sidebar'       - PluginSidebar
  //              'status'        - PluginPostStatusInfo
  //	            '<slot-name>'   - Panel inside sidebar Slot with this name,
  //                                NB! attribute 'slot' should be equal to the name when Slot was added
  // moreItem,
  // moreTitle,
  // moreIcon,
  // allowEmptyValues,        when false and metaValues are empty (undefined or null) - nothing will be rendered
  // initialOpen
  // metaKeys     string|array
  //                          if metaKeys is null or missing - meta data will not be requested and functions for updating them will not be created

  var metadata = {
    slot: 'setting',
    name: 'zu-language',
    title: __('Language'),
    metaKeys: null
  };

  // WordPress dependencies
  var _lodash = lodash,
      forEach = _lodash.forEach,
      isString = _lodash.isString,
      isNil = _lodash.isNil,
      isEmpty = _lodash.isEmpty,
      noop = _lodash.noop,
      filter = _lodash.filter,
      merge = _lodash.merge,
      transform = _lodash.transform;
  var _wp$compose = wp.compose,
      createHigherOrderComponent = _wp$compose.createHigherOrderComponent,
      compose = _wp$compose.compose;
  var _wp$editPost = wp.editPost,
      PluginSidebarMoreMenuItem = _wp$editPost.PluginSidebarMoreMenuItem,
      PluginDocumentSettingPanel = _wp$editPost.PluginDocumentSettingPanel,
      PluginPostStatusInfo = _wp$editPost.PluginPostStatusInfo,
      PluginSidebar = _wp$editPost.PluginSidebar;
  var _wp$components = wp.components,
      Fill = _wp$components.Fill,
      PanelBody = _wp$components.PanelBody;
  var _wp$data = wp.data,
      withSelect = _wp$data.withSelect,
      withDispatch = _wp$data.withDispatch; // Higher-order component which renders the original component inside requested SlotFills

  var withSidebarPlugin = createHigherOrderComponent(function (WrappedComponent) {
    return function (ownProps) {
      var className = ownProps.className,
          name = ownProps.name,
          title = ownProps.title,
          icon = ownProps.icon,
          _ownProps$slot = ownProps.slot,
          slot = _ownProps$slot === void 0 ? 'setting' : _ownProps$slot,
          _ownProps$moreItem = ownProps.moreItem,
          moreItem = _ownProps$moreItem === void 0 ? false : _ownProps$moreItem,
          moreTitle = ownProps.moreTitle,
          moreIcon = ownProps.moreIcon,
          metaValues = ownProps.metaValues,
          _ownProps$allowEmptyV = ownProps.allowEmptyValues,
          allowEmptyValues = _ownProps$allowEmptyV === void 0 ? true : _ownProps$allowEmptyV,
          _ownProps$initialOpen = ownProps.initialOpen,
          initialOpen = _ownProps$initialOpen === void 0 ? true : _ownProps$initialOpen; // when allowEmptyValues is false and metaValues are empty (undefined or null) - nothing will be rendered

      if (!allowEmptyValues && (isNil(metaValues) || isEmpty(filter(metaValues)))) return null;
      if (slot == 'status') return /*#__PURE__*/React.createElement(PluginPostStatusInfo, null, /*#__PURE__*/React.createElement(WrappedComponent, ownProps));
      if (slot == 'setting') return /*#__PURE__*/React.createElement(PluginDocumentSettingPanel, {
        name: name,
        title: title,
        className: className
      }, /*#__PURE__*/React.createElement(WrappedComponent, ownProps));
      if (slot == 'sidebar') return /*#__PURE__*/React.createElement(React.Fragment, null, moreItem && /*#__PURE__*/React.createElement(PluginSidebarMoreMenuItem, {
        target: name,
        icon: moreIcon
      }, moreTitle || title), /*#__PURE__*/React.createElement(PluginSidebar, {
        name: name,
        title: title,
        icon: icon,
        className: className
      }, /*#__PURE__*/React.createElement(WrappedComponent, ownProps))); // otherwise fill in the requested slot

      return /*#__PURE__*/React.createElement(Fill, {
        name: slot,
        className: className
      }, /*#__PURE__*/React.createElement(PanelBody, {
        initialOpen: initialOpen,
        title: title
      }, /*#__PURE__*/React.createElement(WrappedComponent, ownProps)));
    };
  }, 'withSidebarPlugin');

  var withSidebar = function withSidebar(sidebarProps) {
    return compose([// get Sidebar props
    createHigherOrderComponent(function (WrappedComponent) {
      return function (ownProps) {
        return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, ownProps, sidebarProps));
      };
    }, 'withSidebarProps'), // get meta values by keys
    withSelect(function (select, _ref) {
      var metaKeys = _ref.metaKeys;
      // if metaKeys is null or missing(empty) - do nothing
      if (isEmpty(metaKeys)) return {
        metaValues: null,
        meta: null
      }; // metaValues	- object { key: value }
      // meta:		- value of first key in metaKeys array, more often than not - this is the only value

      var _select = select('core/editor'),
          getEditedPostAttribute = _select.getEditedPostAttribute;

      var metaValues = isString(metaKeys) ? _defineProperty({}, metaKeys, getEditedPostAttribute('meta')[metaKeys]) : transform(metaKeys, function (values, key) {
        values[key] = getEditedPostAttribute('meta')[key];
      }, {});
      return {
        meta: metaValues[isString(metaKeys) ? metaKeys : metaKeys[0]],
        metaValues: metaValues
      };
    }), // create function to update meta
    withDispatch(function (dispatch, _ref3) {
      var metaKeys = _ref3.metaKeys,
          meta = _ref3.meta;

      // provide inteface to create notices
      var _dispatch = dispatch('core/notices'),
          createNotice = _dispatch.createNotice; // if metaKeys is null or missing(empty) -  then do nothing else


      if (isEmpty(metaKeys)) return {
        createNotice: createNotice,
        setMetaValues: noop,
        setMetaValue: noop,
        setMetaAttributes: noop
      }; // setMetaValue(object)				- updates meta in the current post for the first key in metaKeys array,
      // 										more often than not - this is the only key
      // setMetaAttributes(object)		- updates attributes for the first key in metaKeys array
      //
      // setMetaValues(object)			- updates meta in the current post from single object { metKey: value }

      var _dispatch2 = dispatch('core/editor'),
          editPost = _dispatch2.editPost; // const updateValue = ;


      var firstKey = isString(metaKeys) ? metaKeys : metaKeys[0];
      return {
        createNotice: createNotice,
        setMetaValue: function setMetaValue(value) {
          return editPost({
            meta: _defineProperty({}, firstKey, value)
          });
        },
        setMetaAttributes: function setMetaAttributes(attributes) {
          return editPost({
            meta: _defineProperty({}, firstKey, merge({}, meta, attributes))
          });
        },
        setMetaValues: function setMetaValues(values) {
          return forEach(values, function (value, key) {
            return editPost({
              meta: _defineProperty({}, key, value)
            });
          });
        }
      };
    }), withSidebarPlugin]);
  };

  /**
   * Utilities for qTranslate blocks
   */
  // 	lang_code_format: '[a-z]{2,3}',
  // 	language_config: {
  // 		en: {
  // 			admin_name: "Американский Английский",
  // 			flag: "gb.png",
  // 			locale: "en_US",
  // 			locale_html: "en",
  // 			name: "English",
  // 		},
  // 		ru: {
  // 			admin_name: "Русский",
  // 			flag: "ru.png",
  // 			locale: "ru_RU",
  // 			locale_html: "ru",
  // 			name: "Русский",
  // 		},
  // 	},
  // };

  /* global qTranslateConfig */

  var qtranxj_get_split_blocks = function qtranxj_get_split_blocks(text) {
    var regex = '(<!--:lang-->|<!--:-->|\\[:lang]|\\[:]|{:lang}|{:})'.replace(/lang/g, qTranslateConfig.lang_code_format);
    var splitRegex = new RegExp(regex, "gi"); // Most browsers support RegExp.prototype[@@split]()... except IE

    if ('a~b'.split(/(~)/).length === 3) {
      return text.split(splitRegex);
    } // compatibility for unsupported engines


    var start = 0,
        arr = [];
    var result;

    while ((result = splitRegex.exec(text)) != null) {
      arr.push(text.slice(start, result.index));
      if (result.length > 1) arr.push(result[1]);
      start = splitRegex.lastIndex;
    }

    if (start < text.length) arr.push(text.slice(start));
    if (start === text.length) arr.push(''); // delimiter at the end

    return arr;
  };
  var qtranxj_split = function qtranxj_split(text) {
    var blocks = qtranxj_get_split_blocks(text);
    return qtranxj_split_blocks(blocks);
  };
  var qtranxj_split_blocks = function qtranxj_split_blocks(blocks) {
    var result = new Object();

    for (var _lang in qTranslateConfig.language_config) {
      result[_lang] = '';
    }

    if (!blocks || !blocks.length) return result;

    if (blocks.length === 1) {
      // no language separator found, enter it to all languages
      var b = blocks[0];

      for (var _lang2 in qTranslateConfig.language_config) {
        result[_lang2] += b;
      }

      return result;
    }

    var clang_regex = new RegExp('<!--:(lang)-->'.replace(/lang/g, qTranslateConfig.lang_code_format), 'gi');
    var blang_regex = new RegExp('\\[:(lang)]'.replace(/lang/g, qTranslateConfig.lang_code_format), 'gi');
    var slang_regex = new RegExp('{:(lang)}'.replace(/lang/g, qTranslateConfig.lang_code_format), 'gi');
    var lang = false;
    var matches;

    for (var i = 0; i < blocks.length; ++i) {
      var _b = blocks[i];
      if (!_b.length) continue;
      matches = clang_regex.exec(_b);
      clang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      matches = blang_regex.exec(_b);
      blang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      matches = slang_regex.exec(_b);
      slang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      if (_b === '<!--:-->' || _b === '[:]' || _b === '{:}') {
        lang = false;
        continue;
      }

      if (lang) {
        if (!result[lang]) result[lang] = _b;else result[lang] += _b;
        lang = false;
      } else {
        // keep neutral text
        for (var key in result) {
          result[key] += _b;
        }
      }
    }

    return result;
  };

  // WordPress dependencies
  var _ = lodash; // Zukit dependencies

  var _wp$zukit$utils = wp.zukit.utils,
      externalData = _wp$zukit$utils.externalData,
      getExternalData = _wp$zukit$utils.getExternalData,
      mergeClasses = _wp$zukit$utils.mergeClasses,
      toJSON = _wp$zukit$utils.toJSON,
      simpleMarkdown = _wp$zukit$utils.simpleMarkdown; // Import debug object and make it available from global scope
  window.Zubug = _objectSpread2({}, wp.zukit.debug || {}); // Internal dependencies

  externalData('zutranslate_blocks_data');
  var supportedData = getExternalData('supported', {});
  var editorLang = getExternalData('lang', 'en');
  var delimiters = ['[]', '{}', '<!-- -->'];

  var supportedBlocks = _.keys(supportedData);

  function getTranslatedAtts(name) {
    return _.castArray(_.get(supportedData, [name, 'atts']));
  }
  function getTranslated(name, attributes) {
    var translatedKeys = getTranslatedAtts(name);

    var translatedAtts = _.reduce(translatedKeys, function (values, attr) {
      values.push(_.get(attributes, attr, ''));
      return values;
    }, []); // _.pick(attributes, translatedKeys);


    return [_.join(translatedKeys, ','), translatedAtts];
  }
  function hasRaw(ref) {
    var _ref$current;

    return !!(ref === null || ref === void 0 ? void 0 : (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.raw);
  }
  function isSupported(name) {
    return _.includes(supportedBlocks, name);
  }
  function hasTranslations(text) {
    var blocks = qtranxj_get_split_blocks(text !== null && text !== void 0 ? text : ''); // no language separator found - there are no translations

    return (blocks === null || blocks === void 0 ? void 0 : blocks.length) > 1; // if (!blocks || !blocks.length)
    // 	return result;
    // if (blocks.length === 1) {
  }
  function getLangContent(raw, lang) {
    var _blocks$lang;

    var blocks = _.isArray(raw) ? qtranxj_split_blocks(raw) : getTranslatedBlocks(raw);
    return (_blocks$lang = blocks[lang]) !== null && _blocks$lang !== void 0 ? _blocks$lang : '';
  }
  function createRawContent(lang, values, translatedAtts) {
    var maybeFixRaw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (values) {
      var separator = marker(testDelimters(), null, null, true);

      var rawItems = _.fill(_.range(0, values.length), ''); // if RAW was created for wrong amount of attributes


      if (maybeFixRaw) {
        var items = _.split(maybeFixRaw, separator);

        if (values.length !== items.length) {
          maybeFixRaw = fixRawContent(lang, values, separator, maybeFixRaw);
        }

        return [maybeFixRaw, {}];
      }

      var prevRaw = _.reduce(values, function (foundRaw, value) {
        return foundRaw === false ? hasTranslations(value) ? value : false : foundRaw;
      }, false);

      if (prevRaw) {
        var index = _.indexOf(values, prevRaw);

        var atts = _.split(translatedAtts !== null && translatedAtts !== void 0 ? translatedAtts : '', ',');

        _.set(rawItems, index, prevRaw);

        return [_.join(rawItems, separator), _defineProperty({}, atts[index], getLangContent(prevRaw, lang))];
      }

      var raw = _.join(rawItems, separator);

      return [updateRawContent(raw, lang, values), {}];
    }

    return [null, {}];
  }
  function updateRawContent(raw, lang) {
    var values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (values) {
      var del = testDelimters(raw);
      var separator = marker(del, null, null, true);

      var content = _.split(raw, separator);

      var rawItems = _.reduce(content, function (newRaw, rawItem, index) {
        var blocks = getTranslatedBlocks(rawItem);

        if (values[index] !== undefined) {
          blocks[lang] = values[index];

          var withMarkers = _.map(blocks, function (text, ln) {
            return marker(del, ln, text);
          });

          newRaw[index] = _.join([].concat(_toConsumableArray(withMarkers), [marker(del)]), '');
        }

        return newRaw;
      }, []);
      return _.join(rawItems, separator);
    }

    return raw;
  }
  function switchContent(raw, lang, translatedAtts) {
    var atts = _.split(translatedAtts, ',');

    var rawItems = splitRawContent(raw);
    return _.reduce(atts, function (attributes, attr, index) {
      var value = getLangContent(rawItems[index], lang);

      _.set(attributes, attr, value);
      return attributes;
    }, {});
  }
  function getInputValue(selector) {
    var _document$querySelect, _document$querySelect2;

    return (_document$querySelect = (_document$querySelect2 = document.querySelector(selector)) === null || _document$querySelect2 === void 0 ? void 0 : _document$querySelect2.value) !== null && _document$querySelect !== void 0 ? _document$querySelect : null;
  }
  function changeInputValue(selector, value) {
    var textarea = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var el = document.querySelector(selector);

    if (el) {
      var prototype = textarea ? window.HTMLTextAreaElement.prototype : window.HTMLInputElement.prototype;
      var nativeInputValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value').set;
      nativeInputValueSetter.call(el, value);
      var ev = new Event('input', {
        bubbles: true
      });
      el.dispatchEvent(ev);
    }
  }
  function addInputListener(selector, callback) {
    var el = document.querySelector(selector); // React chose to make 'onChange' behave like 'onInput' does
    // it does fire when there's a change, just not until the input also loses focus

    if (el) el.addEventListener('input', callback);
  } // internal helpers -----------------------------------------------------------]
  // if RAW was created for wrong amount of attributes

  function fixRawContent(lang, values, separator, currentRaw) {
    var raw = emptyRawContent(values.length);

    _.forEach(values, function (val, index) {
      if (val !== '' && val !== undefined) {
        if (_.includes(currentRaw, val)) {
          var rawItems = _.split(raw, separator);

          rawItems[index] = currentRaw;
          raw = _.join(rawItems, separator);
        } else {
          raw = updateRawContent(raw, lang, values);
        }
      }
    });

    return raw;
  }

  function emptyRawContent(items) {
    var del = testDelimters('');
    var separator = marker(del, null, null, true);
    var blocks = getTranslatedBlocks('');

    var withMarkers = _.map(blocks, function (text, ln) {
      return marker(del, ln, text);
    });

    var emptyRaw = _.join([].concat(_toConsumableArray(withMarkers), [marker(del)]), '');

    var rawItems = _.fill(_.range(0, items), emptyRaw);

    return _.join(rawItems, separator);
  }

  function splitRawContent(raw) {
    var del = testDelimters(raw);
    var separator = marker(del, null, null, true);
    return _.split(raw, separator);
  }

  function getTranslatedBlocks(raw) {
    return qtranxj_split(raw !== null && raw !== void 0 ? raw : '');
  }

  function splitInHalf(s) {
    var str = String(s);
    var middle = Math.floor(str.length / 2);
    return [str.substr(0, middle).trim(), str.substr(middle).trim()];
  }

  function testDelimters(s) {
    var blockDel = splitInHalf(delimiters[0]);

    if (_.isString(s)) {
      _.forEach(delimiters, function (d) {
        var del = splitInHalf(d);
        var regex = new RegExp(marker(del), 'gi');

        if (regex.exec(s) !== null) {
          blockDel = del;
          return false;
        }
      });
    }

    return blockDel;
  }

  function marker(del) {
    var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var split = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return "".concat(del[0]).concat(split ? ',' : ':').concat(lang !== null && lang !== void 0 ? lang : '').concat(del[1]).concat(text !== null && text !== void 0 ? text : '');
  }

  // WordPress dependencies
  var ColorIndicator = wp.components.ColorIndicator; // Internal dependencies

  var panelIndicatorPrefix = 'components-zu-panel-indicator';

  var PanelTitleIndicator = function PanelTitleIndicator(_ref) {
    var className = _ref.className,
        isColor = _ref.isColor,
        title = _ref.title,
        value = _ref.value,
        colored = _ref.colored,
        props = _objectWithoutProperties(_ref, ["className", "isColor", "title", "value", "colored"]);

    return /*#__PURE__*/React.createElement("span", {
      className: className
    }, title, value && (isColor ? /*#__PURE__*/React.createElement(ColorIndicator, _extends({
      className: panelIndicatorPrefix,
      colorValue: value
    }, props)) : /*#__PURE__*/React.createElement("span", _extends({
      className: mergeClasses(panelIndicatorPrefix, _defineProperty({}, colored, colored))
    }, props), value)));
  };

  var _window$qTranslateCon;

  // WordPress dependencies
  var _lodash$1 = lodash,
      map = _lodash$1.map,
      pick = _lodash$1.pick;
  var __$1 = wp.i18n.__;
  var _wp$components$1 = wp.components,
      PanelBody$1 = _wp$components$1.PanelBody,
      Path = _wp$components$1.Path,
      SVG = _wp$components$1.SVG;
  var useCallback = wp.element.useCallback; // Import debug object and make it available from global scope

  window.Zubug = _objectSpread2({}, wp.zukit.debug || {}); // Zukit dependencies

  var SelectItemControl = wp.zukit.components.SelectItemControl; // Internal dependencies

  var _ref = (_window$qTranslateCon = window.qTranslateConfig) !== null && _window$qTranslateCon !== void 0 ? _window$qTranslateCon : {},
      config = _ref.language_config;

  var langOptions = map(config, function (data, key) {
    return {
      value: key,
      label: data.name
    };
  });
  var langPrefix = 'components-zu-lang-control';
  var tick = /*#__PURE__*/React.createElement(SVG, {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React.createElement(Path, {
    d: "M18.3 5.6L9.9 16.9l-4.6-3.4-.9 1.2 5.8 4.3 9.3-12.6z"
  })); // function transformLangValue(value, label, style) {
  // 	return (
  // 		<span className="__lang" style={ style }>{ label }tick</span>
  // 	);
  // }
  // Zubug.data({ langOptions });

  var LangControl = function LangControl(props // 	{
  // 	title,
  // 	lang,
  // 	onClick,
  // 	withPanel,
  // 	...additionalProps
  // }
  ) {
    var title = props.title,
        lang = props.lang,
        onClick = props.onClick,
        withPanel = props.withPanel,
        additionalProps = _objectWithoutProperties(props, ["title", "lang", "onClick", "withPanel"]);

    Zubug.useTrace(props);
    var langValue = useCallback(function (value, label, style) {
      return /*#__PURE__*/React.createElement("span", {
        className: "__lang",
        style: style
      }, label, lang === value ? tick : null);
    }, [lang]);
    var langControl = /*#__PURE__*/React.createElement(SelectItemControl, {
      className: langPrefix // withLabels
      ,
      options: langOptions,
      selectedItem: lang,
      onClick: onClick,
      transformValue: langValue
    });

    if (withPanel) {
      var titleWithIndicator = /*#__PURE__*/React.createElement(PanelTitleIndicator // isColor
      , {
        title: title !== null && title !== void 0 ? title : __$1('Language', 'zu-translate'),
        value: lang
      });
      var panelProps = pick(additionalProps, ['buttonProps', 'className', 'icon', 'opened', 'scrollAfterOpen', 'initialOpen', 'onToggle']); // Zubug.data({ titleWithIndicator, panelProps, lang });

      return /*#__PURE__*/React.createElement(PanelBody$1, _extends({
        title: titleWithIndicator // onToggle={ onPanelToggle }
        // initialOpen={ initialOpen }

      }, panelProps), langControl);
    }

    return langControl;
  };

  LangControl.Panel = function (props) {
    return /*#__PURE__*/React.createElement(LangControl, _extends({
      withPanel: true
    }, props));
  };
  // "typescript": "^4.5.2"
  // "@wordpress/eslint-plugin": "^7.4.0",

  // // WordPress dependencies
  var _lodash$2 = lodash,
      isEqual = _lodash$2.isEqual,
      get = _lodash$2.get;
  var registerStore = wp.data.registerStore; // Internal dependencies

  var ZUTRANSLATE_STORE = 'zutranslate/core';
  var TYPES = {
    CHANGE_LANG: 'CHANGE_LANG',
    SET_RAW: 'SET_RAW',
    UPDATE_RAW: 'UPDATE_RAW'
  };
  var initialState = {
    lang: editorLang,
    dirty: false
  };

  function storeReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var type = action.type,
        key = action.key,
        value = action.value;
    var prevValue = get(state, key, '');
    var lang = get(state, 'lang', ''); // use an interim value to avoid unnecessary rendering
    // when the data does not change after 'action'

    var interim = state,
        newRaw = null;

    switch (type) {
      case TYPES.SET_RAW:
        interim = _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, key, value));
        break;

      case TYPES.UPDATE_RAW:
        newRaw = updateRawContent(prevValue, lang, [value]);
        interim = _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, key, newRaw));
        break;

      case TYPES.CHANGE_LANG:
        interim = _objectSpread2(_objectSpread2({}, state), {}, {
          lang: value
        });
        break;
    }
    return isEqual(state, interim) ? state : interim;
  }

  var storeActions = {
    setRaw: function setRaw(key, value) {
      return {
        type: TYPES.SET_RAW,
        key: key,
        value: value
      };
    },
    updateRaw: function updateRaw(key, value) {
      return {
        type: TYPES.UPDATE_RAW,
        key: key,
        value: value
      };
    },
    changeLang: function changeLang(value) {
      return {
        type: TYPES.CHANGE_LANG,
        value: value
      };
    }
  };
  registerStore(ZUTRANSLATE_STORE, {
    reducer: storeReducer,
    actions: storeActions,
    selectors: {
      getRaw: function getRaw(state, key) {
        return get(state, key);
      },
      getLang: function getLang(state) {
        return get(state, 'lang');
      }
    },
    controls: {}
  });

  // WordPress dependencies
  var _lodash$3 = lodash,
      keys = _lodash$3.keys,
      forEach$1 = _lodash$3.forEach,
      castArray = _lodash$3.castArray,
      includes = _lodash$3.includes,
      some = _lodash$3.some,
      has = _lodash$3.has,
      set = _lodash$3.set;
  var usePrevious = wp.compose.usePrevious;
  var _wp$element = wp.element,
      useReducer = _wp$element.useReducer,
      useEffect = _wp$element.useEffect; // useCallback, useRef

  var _wp$data$1 = wp.data,
      select = _wp$data$1.select,
      dispatch = _wp$data$1.dispatch,
      useSelect = _wp$data$1.useSelect,
      useDispatch = _wp$data$1.useDispatch; // subscribe,

  var _wp = wp,
      apiFetch = _wp.apiFetch; // Internal dependencies
  var supportedAtts = {
    title: '.editor-post-title__input',
    excerpt: '.editor-post-excerpt__textarea .components-textarea-control__input'
  };
  var supportedKeys = keys(supportedAtts);

  function getLang() {
    return select(ZUTRANSLATE_STORE).getLang();
  }
  function getRaw(key) {
    return select(ZUTRANSLATE_STORE).getRaw(key);
  } // Custom hook which get dispatch method for 'lang' change

  function changeLang(value) {
    var _dispatch = dispatch(ZUTRANSLATE_STORE),
        changeLang = _dispatch.changeLang;

    var currentLang = getLang();
    if (value !== currentLang) changeLang(value);
  } // set the initial values for RAW attributes

  function setRawAttributes() {
    var _select = select('core/editor'),
        getEditedPostAttribute = _select.getEditedPostAttribute;

    var _dispatch2 = dispatch(ZUTRANSLATE_STORE),
        setRaw = _dispatch2.setRaw;

    forEach$1(supportedAtts, function (selector, attr) {
      var value = getEditedPostAttribute("".concat(attr, "_raw"));
      setRaw(attr, value);
      addInputListener(selector, function () {
        return updateRawAttributes(attr);
      });
    });
  } // update RAW attributes before changing language
  // (if 'onlyAtts' is not null - update RAW for these attributes only)

  function updateRawAttributes() {
    var onlyAtts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var _dispatch3 = dispatch(ZUTRANSLATE_STORE),
        updateRaw = _dispatch3.updateRaw;

    onlyAtts = onlyAtts === null ? null : castArray(onlyAtts);
    forEach$1(supportedAtts, function (selector, attr) {
      if (onlyAtts === null || includes(onlyAtts, attr)) {
        var value = getInputValue(selector);
        updateRaw(attr, value);
      }
    });
  } // select content for the language from the RAW value and set it in the INPUT element

  function switchRawAttributes(lang) {
    forEach$1(supportedAtts, function (selector, attr) {
      var rawValue = getRaw(attr);

      if (rawValue !== undefined) {
        var renderedValue = getLangContent(rawValue, lang);
        changeInputValue(selector, renderedValue, true);
      }
    });
  }
  function useForceUpdater() {
    var _useReducer = useReducer(function (z) {
      return z + 1;
    }, 0),
        _useReducer2 = _slicedToArray(_useReducer, 2),
        forceUpdate = _useReducer2[1];

    return forceUpdate;
  }
  function useOnLangChange(callback) {
    var editorLang = getLang();
    var prev = usePrevious(editorLang); // ????

    useEffect(function () {
      if (prev !== undefined && prev !== editorLang) callback(editorLang);
    }, [prev, editorLang, callback]);
    return editorLang;
  } // Custom hook to notify on form removal (also collect form names)
  // export const useOnFormRemove = (clientId, postId, name, updateForm) => {
  //
  // 	const formRef = useRef({ clientId, postId, name, updateForm });
  //
  // 	// 'updateForm' will be called on form removing only
  // 	useEffect(() => {
  // 		return () => {
  // 			const { clientId, name, updateForm } = formRef.current || {};
  // 			updateForm(name, TYPES.PURGE_FORM);
  // 			// delete form name from common list
  // 			updateName(clientId, name, true);
  // 		}
  // 	}, []);
  //
  // 	// in order to maintain a list of all the names for the forms on the page
  // 	useEffect(() => {
  // 		updateName(clientId, name);
  // 		formRef.current = { clientId, postId, name, updateForm };
  // 	}, [clientId, postId, name, updateForm]);
  // }
  // Hook on the post saving ----------------------------------------------------]

  var _select2 = select('core/editor'),
      isSavingPost = _select2.isSavingPost;

  apiFetch.use(function (options, next) {

    if (isSavingPost() && includes(['PUT', 'POST'], options.method)) {
      var data = options.data;

      var newOptions = _objectSpread2(_objectSpread2({}, options), {}, {
        data: _objectSpread2(_objectSpread2({}, data), {}, {
          editor_lang: getLang()
        })
      });

      if (some(keys(data), function (val) {
        return includes(supportedKeys, val);
      })) {
        forEach$1(supportedKeys, function (attr) {
          if (has(data, attr)) {
            var rawValue = getRaw(attr);
            set(newOptions, ['data', attr], rawValue);
          }
        });
      }
      return next(newOptions);
    }

    return next(options);
  });

  // WordPress dependencies
  var _lodash$4 = lodash,
      reduce = _lodash$4.reduce,
      has$1 = _lodash$4.has;
  var compose$1 = wp.compose.compose;
  var _wp$data$2 = wp.data,
      withSelect$1 = _wp$data$2.withSelect,
      withDispatch$1 = _wp$data$2.withDispatch;
  var _wp$element$1 = wp.element,
      useCallback$1 = _wp$element$1.useCallback,
      useEffect$1 = _wp$element$1.useEffect; // Zukit dependencies

  var LangControlSetting = function LangControlSetting() // {
  // 	getBlocks,
  // 	updateBlockAttributes,
  // }
  {
    var forceUpdate = useForceUpdater();
    var editorLang = useOnLangChange(switchRawAttributes); //'() => {}); // switchRawAttributes
    // set the initial RAW attributes on mounting the component

    useEffect$1(function () {
      setRawAttributes();
    }, []); // переключаем язык, сохраняем последнее редактированное значение в raw
    // и меняем контент элемента на значение соответсвующее новому языку

    var setLanguage = useCallback$1(function (value) {
      // updateRawAttributes();
      changeLang(value);
      forceUpdate(); // switchAllRelatedBlocks(value, getBlocks, updateBlockAttributes);
    }, [forceUpdate]);
    return /*#__PURE__*/React.createElement(LangControl, {
      lang: editorLang,
      onClick: setLanguage
    });
  };

  var render = compose$1([withSidebar(metadata), withSelect$1(function (select) {
    return {
      getBlocks: select('core/block-editor').getBlocks
    };
  }), withDispatch$1(function (dispatch) {
    // const { updateBlockAttributes } = dispatch('core/block-editor');
    return {
      updateBlockAttributes: dispatch('core/block-editor').updateBlockAttributes
    };
  })])(LangControlSetting);

  // Internal dependencies
  var name = metadata.name,
      title = metadata.title;
  var settings = {
    title: title,
    render: render
  };

  var plugin = /*#__PURE__*/Object.freeze({
    __proto__: null,
    metadata: metadata,
    name: name,
    settings: settings
  });

  // WordPress dependencies
  // const { pick, isNil, assign } = lodash;
  // const { __ } = wp.i18n;
  // const { addFilter } = wp.hooks;
  var createHigherOrderComponent$1 = wp.compose.createHigherOrderComponent; // const { usePrevious } = wp.compose;

  var InspectorControls = wp.blockEditor.InspectorControls;
  var _wp$element$2 = wp.element,
      useEffect$2 = _wp$element$2.useEffect,
      useCallback$2 = _wp$element$2.useCallback,
      useRef = _wp$element$2.useRef,
      useMemo = _wp$element$2.useMemo; // cloneElement, useState, useEffect, useLayoutEffect

  var BlockEditLang = function BlockEditLang(props) {
    var name = props.name,
        setAttributes = props.setAttributes,
        attributes = props.attributes;
    var qtxRaw = attributes.qtxRaw,
        _attributes$qtxLang = attributes.qtxLang,
        qtxLang = _attributes$qtxLang === void 0 ? 'en' : _attributes$qtxLang; // Zubug.useMU();

    var rawRef = useRef(null);

    if (rawRef.current === null) {
      rawRef.current = {
        lang: qtxLang,
        raw: qtxRaw
      }; // Zubug.data({ lang: qtxLang, raw: qtxRaw }, 'Raw loaded');
    }

    var _getTranslated = getTranslated(name, attributes),
        _getTranslated2 = _slicedToArray(_getTranslated, 2),
        translatedAtts = _getTranslated2[0],
        translatedValues = _getTranslated2[1]; // Replace the values of all 'translated' attributes for the required language


    var replaceContent = useCallback$2(function (lang) {
      var raw = rawRef.current.raw;
      var atts = switchContent(raw, lang, translatedAtts);
      rawRef.current.lang = lang;
      setAttributes(_objectSpread2({
        qtxLang: lang
      }, atts));
      Zubug.data({
        atts: atts,
        lang: lang,
        ref: rawRef.current,
        translatedAtts: translatedAtts
      });
    }, [translatedAtts, setAttributes]);
    var onChangeLang = useCallback$2(function (lang) {
      changeLang(lang);
      forceUpdate();
      Zubug.info("Language switched {".concat(lang, "}"));
    }, [forceUpdate]);
    var forceUpdate = useForceUpdater();
    var editorLang = useOnLangChange(replaceContent); // конвертировать content в рав если требуется при маунтинг

    useEffect$2(function () {
      if (!hasRaw(rawRef)) {
        var _createRawContent = createRawContent(qtxLang, translatedValues, translatedAtts),
            _createRawContent2 = _slicedToArray(_createRawContent, 2),
            raw = _createRawContent2[0],
            update = _createRawContent2[1];

        rawRef.current.raw = raw;
        setAttributes(_objectSpread2({
          qtxLang: qtxLang,
          qtxRaw: raw
        }, update));
        Zubug.data({
          lang: qtxLang,
          raw: raw,
          update: update,
          translatedValues: translatedValues,
          translatedAtts: translatedAtts
        }, 'Raw created');
      } else {
        var _raw = rawRef.current.raw;

        var _createRawContent3 = createRawContent(qtxLang, translatedValues, translatedAtts, _raw),
            _createRawContent4 = _slicedToArray(_createRawContent3, 1),
            fixedRaw = _createRawContent4[0];

        Zubug.data({
          raw: rawRef.current.raw,
          fixedRaw: _raw !== fixedRaw ? fixedRaw : null,
          translatedValues: translatedValues,
          translatedAtts: translatedAtts
        }, _raw !== fixedRaw ? 'Raw fixed!' : 'Raw existed!');
        if (_raw !== fixedRaw) rawRef.current.raw = fixedRaw;
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, []); // After each change in one of the attributes that require the translation, we update 'qtxRaw'

    useEffect$2(function () {
      // Zubug.info('attributes changed', translatedValues, rawRef);
      if (hasRaw(rawRef)) {
        var _rawRef$current = rawRef.current,
            raw = _rawRef$current.raw,
            lang = _rawRef$current.lang;
        var updatedRaw = updateRawContent(raw, lang, translatedValues);
        Zubug.data({
          translatedValues: translatedValues,
          updatedRaw: updatedRaw
        });

        if (updatedRaw !== rawRef.current.raw) {
          rawRef.current.raw = updatedRaw;
          setAttributes({
            qtxRaw: updatedRaw
          });
          Zubug.data({
            updatedRaw: updatedRaw,
            translatedValues: translatedValues
          }, 'Raw updated');
        }
      } // we used a spread element in the dependency array -> we can't statically verify the correct dependencies
      // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [].concat(_toConsumableArray(translatedValues), [setAttributes])); // const prevLang = usePrevious(qtxLang);
    // useEffect(() => {
    // 	if(qtxLang !== prevLang) replaceContent(qtxLang);
    // }, [qtxLang, prevLang, replaceContent]);

    return useMemo(function () {
      return /*#__PURE__*/React.createElement(InspectorControls, null, /*#__PURE__*/React.createElement(LangControl.Panel, {
        lang: editorLang,
        onClick: onChangeLang
      }));
    }, [editorLang, onChangeLang]);
  };

  var withRawEditControls = createHigherOrderComponent$1(function (BlockEdit) {
    return function (props) {
      var name = props.name,
          clientId = props.clientId;
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(BlockEdit, props), isSupported(name) && clientId && /*#__PURE__*/React.createElement(BlockEditLang, props));
    };
  }, 'withRawEditControls');

  // WordPress dependencies
  var _lodash$5 = lodash,
      isNil$1 = _lodash$5.isNil,
      assign = _lodash$5.assign; // const { __ } = wp.i18n;

  var addFilter = wp.hooks.addFilter; // const { useEffect, useCallback } = wp.element; // cloneElement, useState, useEffect, useLayoutEffect

  var _wp$data$3 = wp.data,
      select$1 = _wp$data$3.select,
      subscribe = _wp$data$3.subscribe; //

  function addRawAttribute(settings, name) {
    if (!isNil$1(settings.attributes)) {
      if (isSupported(name)) {
        // Zubug.data({ settings });
        settings.attributes = assign({}, settings.attributes, {
          qtxRaw: {
            type: 'string'
          },
          qtxLang: {
            type: 'string'
          }
        }); // Zubug.info(`added attributes to {${name}}`);
      }
    }

    return settings;
  } // const filterBlocks = (settings) => {
  //     console.log(settings.name)
  //     // we need to pass along the settings object
  //     // even if we haven't modified them!
  //     return settings;
  // }
  //
  // addFilter(
  //     'blocks.registerBlockType', // hook name, very important!
  //     'zu/test', // your name, very arbitrary!
  //     filterBlocks // function to run
  // );


  addFilter('blocks.registerBlockType', 'zu/paragraph', addRawAttribute);
  addFilter('editor.BlockEdit', 'zu/paragraph', withRawEditControls); // NOTE: All experiments left here --------------------------------------------]

  var _select = select$1('core/editor'),
      isSavingPost$1 = _select.isSavingPost;

  var postSaved = true;
  subscribe(function () {
    if (isSavingPost$1()) {
      postSaved = false;
      Zubug.info('{isSavingPost}');
    } else {
      if (!postSaved) {
        Zubug.info('~Post Saved~');
        postSaved = true;
      }
    }
  }); // function applyExtraProps(extraProps, blockType, attributes) {
  // 	const {
  // 		content,
  // 		rawContent,
  // 		lang,
  // 	} = attributes;
  // 	if(isSupported(blockType?.name)) {
  // 		Zubug.data({ extraProps, blockType, attributes });
  // 	}
  //
  // 	const blocks = qtranxj_split(rawContent);
  // 	blocks[lang] = content;
  // 	const newLang = lang === 'en' ? 'ru' : 'en';
  // 	Zubug.data({ lang, content,  blocks });
  // 	extraProps.className join([...map(blocks, (text, l) => `[:${l}]${text}`), '[:]'], '')
  //
  // 	if(typeof hideOnMobile !== 'undefined' && hideOnMobile) {
  // 		extraProps.className = extraProps.className + ' hide-on-mobile';
  // 	}
  // 	return extraProps;
  // }
  // addFilter('blocks.getSaveContent.extraProps', 'zu/paragraph', applyExtraProps);
  // function getBlockAttributes(attributes, blockType, param3, param4) {
  // 	if(isSupported(blockType?.name)) {
  // 		const { content, rawContent, lang } = attributes;
  // 		const translated = rawContent ? getLangContent(rawContent, lang) : content;
  // 		attributes.content = translated;
  // 		Zubug.data({ attributes, blockType, param3, param4 });
  // 		return attributes;
  // 	}
  // 	return attributes;
  // }
  // addFilter('blocks.getBlockAttributes', 'zu/paragraph', getBlockAttributes);
  // function getSaveElement(elem, blockType, attributes) {
  // 	const blockName = blockType?.name;
  // 	if(isSupported(blockName)) {
  // 		// Zubug.info('called');
  // 		if(attributes.isXT) {
  // 			// const fallback = () => elem;
  // 			const { rawContent } = attributes;
  // 			const isEdit = !!rawContent;
  // 			// // const save = get(blockSave, blockName) ?? fallback;
  // 			Zubug.info(isSavingPost() ? '{isSavingPost}' : 'update?');
  // 			if(isEdit) {
  // 				attributes.content = rawContent;
  // 				// attributes.rawContent = undefined;
  // 				const newEl = cloneElement(elem, { attributes });
  // 				Zubug.data({ content: attributes.content, rawContent: attributes.rawContent }, 'new Element');
  // 				return newEl;
  // 			}
  // 		}
  // 	}
  // 	return elem;
  // }
  // addFilter('blocks.getSaveElement', 'zu/paragraph', getSaveElement);

  // WordPress dependencies
  var _lodash$6 = lodash,
      defaults = _lodash$6.defaults;
  var registerPlugin = wp.plugins.registerPlugin; // const { registerBlockType } = wp.blocks;
  // Import debug object and make it available from global scope

  window.Zubug = _objectSpread2({}, wp.zukit.debug || {}); // Internal dependencies

  function registerPlugins() {
    [plugin // status,
    ].forEach(function (sidebar) {
      if (!sidebar) return;
      var name = sidebar.name,
          settings = sidebar.settings; // we need to pass {icon: false} if the attribute is missed to avoid rendering the default icon

      registerPlugin(name, defaults(settings, {
        icon: false
      }));
    });
  } // Register ZU blocks collection or category
  // const supportsCollections = registerCollection();
  // if(!supportsCollections) registerCategory();
  //  Register Blocks -----------------------------------------------------------]
  // import * as form from './blocks/form/index.js';
  // import * as recaptcha from './blocks/field-recaptcha/index.js';
  //
  // export function registerBlocks() {
  // 	[
  // 		form,
  // 		recaptcha,
  //
  // 	].forEach(block => {
  //
  // 		if(!block) return;
  //
  // 		const { name, settings } = block;
  // 		if(!supportsCollections) settings.category = brandAssets.slug;
  // 		registerBlockType(name, settings);
  //
  // 	} );
  // }
  //

  registerPlugins(); // registerBlocks();

  exports.registerPlugins = registerPlugins;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
//# sourceMappingURL=zutranslate-blocks.min.js.map
