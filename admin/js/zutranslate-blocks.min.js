var zutranslate_blocks = (function (exports) {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // WordPress dependencies
  var _$1 = lodash;
  var select$5 = wp.data.select; // Zukit dependencies

  var _wp$zukit$utils = wp.zukit.utils,
      externalData = _wp$zukit$utils.externalData,
      getExternalData = _wp$zukit$utils.getExternalData,
      mergeClasses = _wp$zukit$utils.mergeClasses,
      emptyGif = _wp$zukit$utils.emptyGif;
      _wp$zukit$utils.toJSON;
      _wp$zukit$utils.simpleMarkdown; // before calls 'getExternalData', we need to call 'externalData'
  externalData('zutranslate_blocks_data');
  var supportedData = getExternalData('supported', {});

  var supportedBlocks = _$1.keys(supportedData); // import debug object and make it available from global scope


  window.Zubug = _objectSpread2({}, wp.zukit.debug || {});
  var getDebug = function getDebug(enable) {
    return enable ? Zubug : _$1.transform(_$1.keys(Zubug), function (acc, key) {
      return acc[key] = _$1.noop;
    }, {});
  };
  function isSupported(name) {
    return _$1.includes(supportedBlocks, name);
  }
  function getTranslatedAtts(name) {
    return _$1.castArray(_$1.get(supportedData, [name, 'atts']));
  }
  function getTranslated(name, attributes) {
    var translatedKeys = getTranslatedAtts(name);

    var translatedAtts = _$1.reduce(translatedKeys, function (values, attr) {
      values.push(_$1.get(attributes, attr, ''));
      return values;
    }, []);

    return [_$1.join(translatedKeys, ','), translatedAtts];
  } // selector which returns an array containing all block client IDs in the editor.
  // Optionally accepts a root client ID of the block list for which
  // the order should be returned, defaulting to the top-level block order.

  var _select$4 = select$5('core/block-editor'),
      getBlockOrder = _select$4.getBlockOrder; // recursively collect all IDs of 'editable blocks' on the page.


  function getEditorBlocks() {
    var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (_$1.isNil(ids)) ids = getBlockOrder();
    return _$1.reduce(ids, function (blocks, id) {
      var innerIds = getBlockOrder(id);
      var nestedIds = innerIds.length ? getEditorBlocks(innerIds) : innerIds;
      return [].concat(_toConsumableArray(blocks), _toConsumableArray(nestedIds));
    }, ids);
  } // Language Session Storage ---------------------------------------------------]
  // function which returns true if the current environment supports browser
  // sessionStorage, or false otherwise.

  var hasSessionStorageSupport$1 = _$1.once(function () {
    try {
      // Private Browsing in Safari 10 and earlier will throw an error when
      // attempting to set into sessionStorage. The test here is intentional in
      // causing a thrown error as condition bailing from local autosave.
      window.sessionStorage.setItem('__zuTranslateTestSessionStorage', '');
      window.sessionStorage.removeItem('__zuTranslateTestSessionStorage');
      return true;
    } catch (error) {
      return false;
    }
  }); // the edit language corresponds to the current LSB selection
  // or the main admin language for single mode


  var keyEditLanguage = 'qtranslate-xt-admin-edit-language';
  function getSessionLang() {
    return hasSessionStorageSupport$1() ? sessionStorage.getItem(keyEditLanguage) : null;
  }
  function storeSessionLang(lang) {
    if (hasSessionStorageSupport$1()) {
      try {
        sessionStorage.setItem(keyEditLanguage, lang);
      } catch (e) {
        window.console.warn("Failed to store \"".concat(keyEditLanguage, "\"=").concat(lang, " with sessionStorage"), e);
      }
    }
  }

  // WordPress dependencies
  var __$2 = wp.i18n.__; // className,
  // name,
  // title,
  // icon,
  // slot         kind of SlotFills which will be used:
  //              'setting'       - PluginDocumentSettingPanel
  //              'sidebar'       - PluginSidebar
  //              'status'        - PluginPostStatusInfo
  //	            '<slot-name>'   - Panel inside sidebar Slot with this name,
  //                                NB! attribute 'slot' should be equal to the name when Slot was added
  // moreItem,
  // moreTitle,
  // moreIcon,
  // allowEmptyValues,        when false and metaValues are empty (undefined or null) - nothing will be rendered
  // initialOpen

  var metadata = {
    slot: 'setting',
    name: 'zu-language',
    title: __$2('Language', 'zu-translate')
  };

  // Utilities for qTranslate blocks
  var langCodeFormat = getExternalData('format', '');
  var languageConfig = getExternalData('config', []);
  var qtranxj_get_split_blocks = function qtranxj_get_split_blocks(text) {
    var regex = '(<!--:lang-->|<!--:-->|\\[:lang]|\\[:]|{:lang}|{:})'.replace(/lang/g, langCodeFormat);
    var splitRegex = new RegExp(regex, "gi"); // Most browsers support RegExp.prototype[@@split]()... except IE

    if ('a~b'.split(/(~)/).length === 3) {
      return text.split(splitRegex);
    } // compatibility for unsupported engines


    var start = 0,
        arr = [];
    var result;

    while ((result = splitRegex.exec(text)) != null) {
      arr.push(text.slice(start, result.index));
      if (result.length > 1) arr.push(result[1]);
      start = splitRegex.lastIndex;
    }

    if (start < text.length) arr.push(text.slice(start));
    if (start === text.length) arr.push(''); // delimiter at the end

    return arr;
  };
  var qtranxj_split = function qtranxj_split(text) {
    var blocks = qtranxj_get_split_blocks(text);
    return qtranxj_split_blocks(blocks);
  };
  var qtranxj_split_blocks = function qtranxj_split_blocks(blocks) {
    var result = new Object();

    for (var _lang in languageConfig) {
      result[_lang] = '';
    }

    if (!blocks || !blocks.length) return result;

    if (blocks.length === 1) {
      // no language separator found, enter it to all languages
      var b = blocks[0];

      for (var _lang2 in languageConfig) {
        result[_lang2] += b;
      }

      return result;
    }

    var clang_regex = new RegExp('<!--:(lang)-->'.replace(/lang/g, langCodeFormat), 'gi');
    var blang_regex = new RegExp('\\[:(lang)]'.replace(/lang/g, langCodeFormat), 'gi');
    var slang_regex = new RegExp('{:(lang)}'.replace(/lang/g, langCodeFormat), 'gi');
    var lang = false;
    var matches;

    for (var i = 0; i < blocks.length; ++i) {
      var _b = blocks[i];
      if (!_b.length) continue;
      matches = clang_regex.exec(_b);
      clang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      matches = blang_regex.exec(_b);
      blang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      matches = slang_regex.exec(_b);
      slang_regex.lastIndex = 0;

      if (matches != null) {
        lang = matches[1];
        continue;
      }

      if (_b === '<!--:-->' || _b === '[:]' || _b === '{:}') {
        lang = false;
        continue;
      }

      if (lang) {
        if (!result[lang]) result[lang] = _b;else result[lang] += _b;
        lang = false;
      } else {
        // keep neutral text
        for (var key in result) {
          result[key] += _b;
        }
      }
    }

    return result;
  };

  // WordPress dependencies
  var _ = lodash; // Internal dependencies
  function hasRaw(ref) {
    var _ref$current;

    return !!(ref !== null && ref !== void 0 && (_ref$current = ref.current) !== null && _ref$current !== void 0 && _ref$current.raw);
  }
  function getLangContent(raw, lang) {
    var _blocks$lang;

    var blocks = _.isArray(raw) ? qtranxj_split_blocks(raw) : getTranslatedBlocks(raw);
    return (_blocks$lang = blocks[lang]) !== null && _blocks$lang !== void 0 ? _blocks$lang : '';
  }
  function createRawContent(lang, values, translatedAtts) {
    var maybeFixRaw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var del = getDefaultDelimter();
    var separator = getSeparator();
    var rawItems = emptyRawContent(values.length, false); // if RAW was created for wrong amount of attributes

    if (maybeFixRaw) {
      var items = _.split(maybeFixRaw, separator);

      if (values.length !== items.length) {
        maybeFixRaw = fixRawContent(lang, values, separator, maybeFixRaw);
      }

      return [maybeFixRaw, {}];
    } // check if any of the attributes already contains a RAW block


    var prevRaw = _.reduce(values, function (foundRaw, value) {
      return foundRaw === false ? hasRawBlocks(value) ? value : false : foundRaw;
    }, false);
    // NOTE: the option when more than one attribute contained RAW is not processed
    // this seems to be impossible - before this plugin the RAW was not split by attributes
    // return the new RAW and attribute content for the current language

    if (prevRaw) {
      var index = _.indexOf(values, prevRaw);

      var atts = _.split(translatedAtts !== null && translatedAtts !== void 0 ? translatedAtts : '', ',');

      var newItems = updateRawContent(rawItems, lang, values, {
        del: testDelimters(prevRaw),
        separator: separator,
        join: false
      });

      _.set(newItems, index, prevRaw);

      return [_.join(newItems, separator), _defineProperty({}, atts[index], getLangContent(prevRaw, lang))];
    } // for the newly created RAW, save the current attribute values in the current language section


    return [updateRawContent(rawItems, lang, values, {
      del: del,
      separator: separator
    }), {}];
  }
  function updateRawContent(raw, lang, values) {
    var _$get, _$get2;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    if (lang === undefined) return raw;
    var del = (_$get = _.get(options, 'del')) !== null && _$get !== void 0 ? _$get : testDelimters(raw);
    var separator = (_$get2 = _.get(options, 'separator')) !== null && _$get2 !== void 0 ? _$get2 : getSeparator(del);

    var joinItems = _.get(options, 'join', true);

    var items = _.isArray(raw) ? raw : _.split(raw, separator);

    var rawItems = _.reduce(items, function (newRaw, rawItem, index) {
      var blocks = getTranslatedBlocks(rawItem);

      if (values[index] !== undefined) {
        blocks[lang] = values[index];

        var withMarkers = _.map(blocks, function (text, ln) {
          return marker(del, ln, text);
        });

        newRaw[index] = _.join([].concat(_toConsumableArray(withMarkers), [marker(del)]), '');
      }

      return newRaw;
    }, []);
    return joinItems ? _.join(rawItems, separator) : rawItems;
  } // fix if RAW was created for wrong amount of attributes

  function maybeFixRawContent(prevRaw, lang, values) {
    var separator = getSeparator();

    var items = _.split(prevRaw, separator);

    if (values.length !== items.length) {
      var fixedRaw = fixRawContent(lang, values, separator, prevRaw);
      return prevRaw !== fixedRaw ? fixedRaw : false;
    }

    return false;
  }
  function splitAtts(translatedAtts) {
    return _.split(translatedAtts, ',');
  }
  function switchContent(raw, lang, translatedAtts) {
    var atts = splitAtts(translatedAtts);
    var rawItems = splitRawContent(raw);
    return _.reduce(atts, function (attributes, attr, index) {
      var value = getLangContent(rawItems[index], lang);

      _.set(attributes, attr, value);
      return attributes;
    }, {});
  }
  function hasRawBlocks(text) {
    if (!_.isString(text)) return false;
    var blocks = qtranxj_get_split_blocks(text); // no language separator found - there are no translations

    return (blocks === null || blocks === void 0 ? void 0 : blocks.length) > 1;
  } // internal helpers -----------------------------------------------------------]

  var delimiters = ['[]', '{}', '<!-- -->'];

  function emptyRawContent(itemCount) {
    var joinItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var del = getDefaultDelimter();
    var separator = getSeparator(del);
    var blocks = getTranslatedBlocks('');

    var withMarkers = _.map(blocks, function (text, ln) {
      return marker(del, ln, text);
    });

    var emptyRaw = _.join([].concat(_toConsumableArray(withMarkers), [marker(del)]), '');

    var rawItems = _.fill(_.range(0, itemCount), emptyRaw);

    return joinItems ? _.join(rawItems, separator) : rawItems;
  }

  function splitRawContent(raw) {
    var del = testDelimters(raw);
    var separator = getSeparator(del);
    return _.split(raw, separator);
  }

  function getTranslatedBlocks(raw) {
    return _.isString(raw) ? qtranxj_split(raw) : [];
  } // if RAW was created for wrong amount of attributes


  function fixRawContent(lang, values, separator, currentRaw) {
    var raw = emptyRawContent(values.length);

    _.forEach(values, function (val, index) {
      if (val !== '' && val !== undefined) {
        if (_.includes(currentRaw, val)) {
          var rawItems = _.split(raw, separator);

          rawItems[index] = currentRaw;
          raw = _.join(rawItems, separator);
        } else {
          raw = updateRawContent(raw, lang, values, {
            separator: separator
          });
        }
      }
    });

    return raw;
  } // 'delimter' is what separates blocks of text in different languages


  function getDefaultDelimter() {
    return testDelimters();
  } // 'separator' is what separates RAW blocks for different attributes


  function getSeparator(del) {
    return marker(del !== null && del !== void 0 ? del : getDefaultDelimter(), null, null, true);
  }

  function splitInHalf(s) {
    var str = String(s);
    var middle = Math.floor(str.length / 2);
    return [str.substr(0, middle).trim(), str.substr(middle).trim()];
  }

  function testDelimters(s) {
    var blockDel = splitInHalf(delimiters[0]);

    if (_.isString(s)) {
      _.forEach(delimiters, function (d) {
        var del = splitInHalf(d);
        var regex = new RegExp(marker(del), 'gi');

        if (regex.exec(s) !== null) {
          blockDel = del;
          return false;
        }
      });
    }

    return blockDel;
  }

  function marker(del) {
    var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var split = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return "".concat(del[0]).concat(split ? ',' : ':').concat(lang !== null && lang !== void 0 ? lang : '').concat(del[1]).concat(text !== null && text !== void 0 ? text : '');
  }

  // WordPress dependencies
  var _lodash$c = lodash,
      isEqual$1 = _lodash$c.isEqual,
      get$3 = _lodash$c.get,
      omit = _lodash$c.omit,
      without = _lodash$c.without;
  var registerStore = wp.data.registerStore; // Internal dependencies
  var editorLang = getExternalData('lang', 'en');
  var enableDebug$7 = getExternalData('debug.raw_store', false);
  var debug$7 = getDebug(enableDebug$7); // Create and register Zu Translate store -------------------------------------]

  var supportedKeys = ['title', 'excerpt'];
  var ZUTRANSLATE_STORE = 'zutranslate/core';
  var TYPES = {
    SET_LANG: 'SET_LANG',
    SET_RAW: 'SET_RAW',
    UPDATE_RAW: 'UPDATE_RAW',
    SET_HOOK: 'SET_HOOK',
    REMOVE_HOOK: 'REMOVE_HOOK',
    WATCH: 'WATCH',
    UNWATCH: 'UNWATCH'
  };
  var initialState = {
    lang: editorLang,
    hooks: {},
    watched: []
  };

  function storeReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var type = action.type,
        key = action.key,
        value = action.value;
    var prevValue = get$3(state, key, '');
    var lang = get$3(state, 'lang', ''); // use an interim value to avoid unnecessary rendering
    // when the data does not change after 'action'

    var interim = state,
        newRaw = null;

    switch (type) {
      case TYPES.SET_RAW:
        interim = _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, key, value));
        break;

      case TYPES.UPDATE_RAW:
        newRaw = updateRawContent(prevValue, lang, [value]);
        interim = _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, key, newRaw));
        break;

      case TYPES.SET_LANG:
        interim = _objectSpread2(_objectSpread2({}, state), {}, {
          lang: value
        });
        break;

      case TYPES.SET_HOOK:
        interim = _objectSpread2(_objectSpread2({}, state), {}, {
          hooks: _objectSpread2(_objectSpread2({}, state.hooks), {}, _defineProperty({}, key, value))
        });
        break;

      case TYPES.REMOVE_HOOK:
        interim = _objectSpread2(_objectSpread2({}, state), {}, {
          hooks: omit(state.hooks, key)
        });
        break;

      case TYPES.WATCH:
        interim = _objectSpread2(_objectSpread2({}, state), {}, {
          watched: [].concat(_toConsumableArray(state.watched), [value])
        });
        break;

      case TYPES.UNWATCH:
        interim = _objectSpread2(_objectSpread2({}, state), {}, {
          watched: without(state.watched, value)
        });
        break;
    }

    var hasChanged = !isEqual$1(state, interim);
    debug$7.data({
      type: type,
      key: key,
      value: value,
      prev: state,
      state: hasChanged ? interim : '=prev'
    }, hasChanged ? 'effective change' : 'same as the previous');
    return hasChanged ? interim : state;
  }

  var storeActions = {
    setRaw: function setRaw(key, value) {
      return {
        type: TYPES.SET_RAW,
        key: key,
        value: value
      };
    },
    updateRaw: function updateRaw(key, value) {
      return {
        type: TYPES.UPDATE_RAW,
        key: key,
        value: value
      };
    },
    setLang: function setLang(value) {
      return {
        type: TYPES.SET_LANG,
        value: value
      };
    },
    setHook: function setHook(id, hook) {
      return {
        type: TYPES.SET_HOOK,
        key: id,
        value: hook
      };
    },
    removeHook: function removeHook(id) {
      return {
        type: TYPES.REMOVE_HOOK,
        key: id
      };
    },
    addWatched: function addWatched(id) {
      return {
        type: TYPES.WATCH,
        value: id
      };
    },
    removeWatched: function removeWatched(id) {
      return {
        type: TYPES.UNWATCH,
        value: id
      };
    },
    refresh: function refresh() {
      return {
        type: 'refresh'
      };
    }
  };
  var store = registerStore(ZUTRANSLATE_STORE, {
    reducer: storeReducer,
    actions: storeActions,
    selectors: {
      getRaw: function getRaw(state, key) {
        return get$3(state, key);
      },
      getLang: function getLang(state) {
        return get$3(state, 'lang');
      },
      getHooks: function getHooks(state) {
        return get$3(state, 'hooks');
      },
      getWatched: function getWatched(state) {
        return get$3(state, 'watched');
      }
    },
    controls: {}
  });
  var subscribe$3 = store.subscribe;

  // WordPress dependencies
  var _lodash$b = lodash,
      keys$3 = _lodash$b.keys,
      forEach$5 = _lodash$b.forEach,
      includes$3 = _lodash$b.includes;
  var sprintf$2 = wp.i18n.sprintf;
  var _wp$data$4 = wp.data,
      select$4 = _wp$data$4.select,
      dispatch$2 = _wp$data$4.dispatch; // Internal dependencies
  var enableDebug$6 = getExternalData('debug.sync_blocks', false);
  var activateSync$1 = getExternalData('sync', false);
  var cleanUnsaved = getExternalData('unsaved', false);
  var debug$6 = getDebug(enableDebug$6);
  var rootClientId = 'rawRoot'; // Helpers for 'store' --------------------------------------------------------]
  // we need to know when all changes are committed in 'Entity'
  // to do this, we add a block ID to the 'watched' list before the changes
  // and then remove this ID when the changes were made
  // when the 'watched' list becomes empty - all changes were committed

  function getWatched() {
    return select$4(ZUTRANSLATE_STORE).getWatched();
  }

  function addWatched(id) {
    var isOriginator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var _dispatch = dispatch$2(ZUTRANSLATE_STORE),
        addWatched = _dispatch.addWatched;

    debug$6.infoWithId(id, "-#{+Component added}".concat(isOriginator ? ' [originator]' : ''));
    addWatched(id);
  }

  function removeWatched(id) {
    var _dispatch2 = dispatch$2(ZUTRANSLATE_STORE),
        removeWatched = _dispatch2.removeWatched;

    var count = getWatched().length - 1;
    debug$6.infoWithId(id, "-".concat(count < 0 ? '!' : '#', "{*Component will be removed}, remained in the list [").concat(count, "]"));
    removeWatched(id);
  }

  function getHooks() {
    return select$4(ZUTRANSLATE_STORE).getHooks();
  }

  function refreshStore() {
    return dispatch$2(ZUTRANSLATE_STORE).refresh();
  } // Sync blocks ----------------------------------------------------------------]
  // store some 'Entity' states to synchronize blocks and reset 'dirty' editing state


  var entityState = {
    isPostDirty: false,
    isPostPublished: false,
    isTracking: false,
    shouldResetEdits: false
  }; // call all registered hooks besides associated with 'clientId'
  // this will lead to switching language for blocks associated with these hooks

  function syncBlocks() {
    var clientId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : rootClientId;
    var withoutOriginator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    notifySync('before', activateSync$1, withoutOriginator); // a special case when we need to synchronize blocks when initialized
    // in this situation, the 'rootClientId' is not added to the 'watched' list

    if (!withoutOriginator) addWatched(clientId, true);

    if (activateSync$1) {
      var hooks = getHooks();
      forEach$5(hooks, function (hook, id) {
        if (id !== clientId) {
          // always add watched ID before calling the hook, because inside the hook may be logic
          // to remove this ID from the 'watched' list
          // for example, in the language switch logic for 'non-block' attributes
          addWatched(id);
          hook();
        }
      });
    }

    notifySync('after', activateSync$1);
  }
  function syncCompleted() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : rootClientId;
    var watched = getWatched();
    if (includes$3(watched, id)) removeWatched(id);else refreshStore();
  }

  function notifySync(when) {
    var isEnabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var withoutOriginator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isPostDirty = entityState.isPostDirty,
        isPostPublished = entityState.isPostPublished,
        shouldResetEdits = entityState.shouldResetEdits;

    if (cleanUnsaved && isPostPublished) {
      if (when === 'before' && !isPostDirty) {
        entityState.shouldResetEdits = true;
      }

      if (when === 'after' && shouldResetEdits) {
        entityState.isTracking = true;
      }
    }

    debugSync(when, isEnabled, withoutOriginator);
  } // Internal debug helpers -----------------------------------------------------]


  function debugSync(when, isSyncEnabled, mode) {
    var isPostDirty = entityState.isPostDirty,
        isPostPublished = entityState.isPostPublished,
        isTracking = entityState.isTracking,
        shouldResetEdits = entityState.shouldResetEdits;
    var isBefore = when === 'before';
    var isDisabled = !(cleanUnsaved && isPostPublished);
    var resetNote = sprintf$2('reset is {%s}', isTracking ? shouldResetEdits ? '*enabled' : 'disabled' : '!not tracked');
    var disableNote = sprintf$2('clean "unsaved" is {%s}', isPostPublished ? 'disabled' : '!not possible');
    var info = sprintf$2('-%1$s{%2$s} Sync Blocks [sync %3$s%4$s] - Post [%5$s] and is {%6$s}%7$s%8$s', '#', // 1
    isBefore ? '?initiated' : '*completed', // 2
    isSyncEnabled ? 'enabled' : mode ? 'single mode' : 'disabled', // 3
    mode ? ', without originator' : '', // 4
    isPostPublished ? 'published' : 'not published', // 5
    isPostDirty ? '!dirty' : '*clean', // 6
    isBefore ? ", \"Hooks\" count [".concat(keys$3(getHooks()).length, "]") : '', // 7
    !isBefore && isPostDirty ? ", ".concat(isDisabled ? disableNote : resetNote) : '' // 8
    );
    debug$6.info(info);
  }

  // WordPress dependencies
  var _lodash$a = lodash,
      keys$2 = _lodash$a.keys,
      forEach$4 = _lodash$a.forEach,
      includes$2 = _lodash$a.includes,
      some = _lodash$a.some,
      has$3 = _lodash$a.has,
      set$4 = _lodash$a.set;
  var usePrevious = wp.compose.usePrevious;
  var useEffect$2 = wp.element.useEffect;
  var _wp$data$3 = wp.data,
      select$3 = _wp$data$3.select,
      dispatch$1 = _wp$data$3.dispatch;
  var _wp = wp,
      apiFetch = _wp.apiFetch; // Internal dependencies
  var supportSession$1 = getExternalData('session', false);
  var enableDebug$5 = getExternalData('debug.raw_helpers', false);
  var debug$5 = getDebug(enableDebug$5); // Custom hooks & helpers for 'store' -----------------------------------------]

  function getLang() {
    return select$3(ZUTRANSLATE_STORE).getLang();
  }
  function getRaw(key) {
    return select$3(ZUTRANSLATE_STORE).getRaw(key);
  }
  function setRaw(attribute, value) {
    var _dispatch = dispatch$1(ZUTRANSLATE_STORE),
        setRawValue = _dispatch.setRaw;

    setRawValue(attribute, value);
  }
  function updateRaw(attribute, value) {
    var _dispatch2 = dispatch$1(ZUTRANSLATE_STORE),
        updateRawValue = _dispatch2.updateRaw;

    updateRawValue(attribute, value);
  }
  function addHook(id, hook) {
    var hooks = select$3(ZUTRANSLATE_STORE).getHooks();

    if (!has$3(hooks, id)) {
      dispatch$1(ZUTRANSLATE_STORE).setHook(id, hook);
    }
  }
  function removeHook(id) {
    dispatch$1(ZUTRANSLATE_STORE).removeHook(id);
  } // custom hook which get dispatch method for 'lang' change

  function changeLang(value) {
    var _dispatch3 = dispatch$1(ZUTRANSLATE_STORE),
        setLang = _dispatch3.setLang;

    var currentLang = getLang();

    if (value !== currentLang) {
      if (supportSession$1) storeSessionLang(value);
      setLang(value);
    }
  }
  function useOnLangChange(clientId, callback, prevLang) {
    var editorLang = getLang();
    var prev = usePrevious(prevLang !== null && prevLang !== void 0 ? prevLang : editorLang);
    useEffect$2(function () {
      // if the previous language value is defined and not equal to the current value - call the 'callback' function
      var enable = prev !== undefined && prev !== editorLang;
      debug$5.infoWithId(clientId, "-^on lang change : {".concat(enable ? '*will switch' : '#will skip', "}"), {
        prev: prev,
        editorLang: editorLang
      });

      if (enable) {
        callback(editorLang);
      }

      syncCompleted(clientId);
    }, [prev, editorLang, clientId, callback]);
    return editorLang;
  }
  function useLangHook(clientId, updater) {
    useEffect$2(function () {
      addHook(clientId, updater);
      return function () {
        return removeHook(clientId);
      }; // 'clientId' and 'updater' never change, 'useEffect' will be called only on mounting and unmounting the component
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
  } // Hook on the post saving ----------------------------------------------------]

  var _select$3 = select$3('core/editor'),
      isSavingPost$1 = _select$3.isSavingPost;

  apiFetch.use(function (options, next) {
    if (isSavingPost$1() && includes$2(['PUT', 'POST'], options.method)) {
      var data = options.data;

      var newOptions = _objectSpread2(_objectSpread2({}, options), {}, {
        data: _objectSpread2(_objectSpread2({}, data), {}, {
          editor_lang: getLang()
        })
      });

      if (some(keys$2(data), function (val) {
        return includes$2(supportedKeys, val);
      })) {
        forEach$4(supportedKeys, function (attr) {
          if (has$3(data, attr)) {
            var rawValue = getRaw(attr);
            set$4(newOptions, ['data', attr], rawValue);
          }
        });
      }

      debug$5.data({
        newOptions: newOptions
      });
      return next(newOptions);
    }

    return next(options);
  });

  // WordPress dependencies
  var _lodash$9 = lodash,
      isEmpty$3 = _lodash$9.isEmpty,
      keys$1 = _lodash$9.keys,
      pick$2 = _lodash$9.pick,
      get$2 = _lodash$9.get,
      set$3 = _lodash$9.set,
      forEach$3 = _lodash$9.forEach,
      every = _lodash$9.every,
      has$2 = _lodash$9.has,
      reduce = _lodash$9.reduce;
  var sprintf$1 = wp.i18n.sprintf;
  var _wp$data$2 = wp.data,
      subscribe$2 = _wp$data$2.subscribe,
      select$2 = _wp$data$2.select,
      dispatch = _wp$data$2.dispatch; // Internal dependencies

  var _select$2 = select$2('core/editor'),
      isEditedPostDirty$1 = _select$2.isEditedPostDirty,
      isCurrentPostPublished$1 = _select$2.isCurrentPostPublished,
      getCurrentPostType$1 = _select$2.getCurrentPostType,
      getCurrentPostId$2 = _select$2.getCurrentPostId;

  var _select2$1 = select$2('core'),
      getEntityRecordNonTransientEdits$1 = _select2$1.getEntityRecordNonTransientEdits,
      getEditedEntityRecord$1 = _select2$1.getEditedEntityRecord;

  var _dispatch = dispatch('core'),
      editEntityRecord = _dispatch.editEntityRecord,
      receiveEntityRecords = _dispatch.receiveEntityRecords;

  var enableDebug$4 = getExternalData('debug.edited_entity', false);
  var debug$4 = getDebug(enableDebug$4); // local storage for current attribute values

  var editedAttributes = null; // Attributes of the Entity (debug - blue) ------------------------------------]

  function initEditedAttribute(attr, listener) {
    var rawAttr = "".concat(attr, "_raw");
    if (!editedAttributes) editedAttributes = {};
    var atts = getEntityAttributes([attr, rawAttr]);
    setEditedAttributes(_defineProperty({}, attr, get$2(atts, attr)));
    set$3(editedAttributes, [attr, 'listener'], listener);
    editedAttributes.isReady = every(supportedKeys, function (attr) {
      return has$2(editedAttributes, attr);
    });
    if (editedAttributes.isReady) debug$4.info('-^{+ready} Edited Attributes', editedAttributes);
    return get$2(atts, rawAttr);
  }
  function getEntityAttributes() {
    var onlyAtts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var postType = getCurrentPostType$1();
    var postId = getCurrentPostId$2();
    var entityRecord = getEditedEntityRecord$1('postType', postType, postId);
    return pick$2(entityRecord, onlyAtts !== null && onlyAtts !== void 0 ? onlyAtts : supportedKeys);
  }
  function updateEntityAttributes(edits) {
    if (!isEmpty$3(edits)) {
      debug$4.info('-^{updated} - Entity Attributes', edits);
      var postType = getCurrentPostType$1();
      var postId = getCurrentPostId$2(); // definitely need to be called before 'editEntityRecord'

      setEditedAttributes(edits);
      editEntityRecord('postType', postType, postId, edits);
    } else {
      debug$4.info('-^{#not updated} - Entity Attributes', edits);
    }

    syncCompleted();
  } // Local 'edited' Attributes (debug - blue) -----------------------------------]

  function setEditedAttributes(edits) {
    var prevOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    forEach$3(edits, function (value, attr) {
      if (!prevOnly) set$3(editedAttributes, [attr, 'value'], value);
      set$3(editedAttributes, ['prevEdits', attr], value);
    });
  }

  function updateEditedAttributes(edits) {
    forEach$3(edits, function (value, attr) {
      var listener = editedAttributes[attr].listener;
      set$3(editedAttributes, [attr, 'value'], value);
      listener(attr, value);
      debug$4.info("-^updated RAW for is ".concat(attr, " - [").concat(value, "]"));
    });
  }

  function diffEdits(edits) {
    var _editedAttributes = editedAttributes,
        prevEdits = _editedAttributes.prevEdits;
    var entityAtts = keys$1(edits).length !== keys$1(prevEdits).length ? getEntityAttributes() : {};
    var changes = reduce(prevEdits, function (acc, prev, attr) {
      var _edits$attr;

      var value = (_edits$attr = edits[attr]) !== null && _edits$attr !== void 0 ? _edits$attr : entityAtts[attr];
      if (value !== prev) acc[attr] = value;
      return acc;
    }, {});
    var hasChanges = keys$1(changes).length > 0;
    if (hasChanges) setEditedAttributes(changes, true);
    return hasChanges ? changes : null;
  }

  function hasEditedAttributes() {
    return editedAttributes && editedAttributes.isReady;
  } // Maintaining 'non-modified' content (debug - brown) -------------------------]


  subscribe$2(function () {
    // track post state (Published & Dirty)
    if (isCurrentPostPublished$1() && !entityState.isPostPublished) {
      entityState.isPostPublished = true;
    }

    if (isEditedPostDirty$1()) {
      if (!entityState.isPostDirty) {
        entityState.isPostDirty = true; // entityState.wasDirty = false;

        debugPostStatus$1();
      }
    } else {
      if (entityState.isPostDirty) {
        entityState.isPostDirty = false; // entityState.wasDirty = true;

        debugPostStatus$1();
      }
    } // track update of supported attributes (should be always after Published & Dirty)


    var _testEdits = testEdits(),
        _testEdits2 = _slicedToArray(_testEdits, 2),
        hasUpdates = _testEdits2[0],
        edits = _testEdits2[1];

    if (hasUpdates) {
      debug$4.info('#{test} edits', edits);
      updateEditedAttributes(edits);
    }
  });
  subscribe$3(function () {
    // we need to wait when all changes are committed in 'Entity'
    // otherwise we will start 'reset' ahead of time
    if (entityState.isTracking && changesAreCommitted()) {
      entityState.isTracking = false;
      debug$4.info('-#RAW store tracking is {*completed}', entityState);
      resetEdits();
    }
  });

  function changesAreCommitted() {
    return getWatched().length === 0;
  }

  function getNonTransientEdits() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var recordId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var postType = name !== null && name !== void 0 ? name : getCurrentPostType$1();
    var postId = recordId !== null && recordId !== void 0 ? recordId : getCurrentPostId$2();
    return getEntityRecordNonTransientEdits$1('postType', postType, postId);
  }

  function testEdits() {
    if (hasEditedAttributes()) {
      var edits = pick$2(getNonTransientEdits(), supportedKeys);
      var changes = diffEdits(edits);
      return changes ? [true, changes] : [false];
    }

    return [false];
  }

  function resetEdits() {
    var nonTransientEdits = getNonTransientEdits();
    debug$4.info('-#{?reset} edits', keys$1(nonTransientEdits));

    if (!isEmpty$3(nonTransientEdits)) {
      emulateSavingPost(nonTransientEdits);
      entityState.shouldResetEdits = false;
    }
  } // For emulation, we repeat what the WordPress is doing after saving the post
  // it calls action 'receiveEntityRecords' with data received from the server
  // we have no data from the server, but we just take the latest changes from Entity
  // when we return the data that are equal to the latest changes,
  // then the 'Data Store' considers that the data has been successfully saved and resets the accumulated changes


  function emulateSavingPost(postEdits) {
    var postType = getCurrentPostType$1();
    var postId = getCurrentPostId$2();
    var updatedRecord = getEditedEntityRecord$1('postType', postType, postId);
    var nonTransientEdits = postEdits !== null && postEdits !== void 0 ? postEdits : getNonTransientEdits(postType, postId);

    var edits = _objectSpread2({
      id: postId
    }, nonTransientEdits);

    debug$4.info("-?emulate {Saving Post} [".concat(postId, "]"), nonTransientEdits);
    receiveEntityRecords('postType', postType, updatedRecord, undefined, true, edits);
  }

  function debugPostStatus$1() {
    if (enableDebug$4) {
      var isPostPublished = entityState.isPostPublished,
          isPostDirty = entityState.isPostDirty,
          shouldResetEdits = entityState.shouldResetEdits;
      var args = [sprintf$1('-#Post [%s] and editing state is {%s}', isPostPublished ? 'published' : 'not published', isPostDirty ? '!dirty' : '*clean')];
      !shouldResetEdits && args.push(keys$1(getNonTransientEdits()));
      debug$4.info.apply(debug$4, args);
    }
  }

  // use MutationObserver to find out when the desired elements have mutated
  var observers = {
    inserted: {},
    removed: {}
  };
  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
  var doc = window.document;
  var rootSeparator = '@';

  function whenNode(root, selector, callback, inserted) {
    var selectorWithRoot = root ? safeSelector([root, selector]) : selector;

    function processNode() {
      inserted ? checkInserted(selectorWithRoot, callback) : checkRemoved(selectorWithRoot, callback);
    }

    var rootNode = getRootNode(root); // watch for changes in the document

    if (rootNode) {
      var observer = new MutationObserver(processNode);
      observer.observe(rootNode, {
        childList: true,
        subtree: true
      });
      addObserver(observer, root ? [root, selector] : selector, inserted);
    } // check if the element is currently in the DOM (if 'inserted' is true)
    // or was removed (if 'inserted' is false)


    processNode();
  }

  function whenNodeInserted(root, selector, callback) {
    whenNode(root, selector, callback, true);
  }

  function checkInserted(selectorWithRoot, callback) {
    var _splitSelector = splitSelector(selectorWithRoot),
        _splitSelector2 = _slicedToArray(_splitSelector, 2),
        root = _splitSelector2[0],
        selector = _splitSelector2[1];

    var rootNode = getRootNode(root); // check DOM for elements matching a selector

    rootNode.querySelectorAll(selector).forEach(function (element) {
      // make sure the callback isn't invoked with the same element more than once
      if (!element.ready) {
        element.ready = true; // invoke the callback with the element

        callback(element);
      }
    }); // $(selector).each(function() {
    //     const element = this;
    //     // make sure the callback isn't invoked with the same element more than once
    //     if (!element.ready) {
    //         element.ready = true;
    //         // invoke the callback with the element
    //         callback(element);
    //     }
    // });
  }

  function checkRemoved(selectorWithRoot, callback) {
    var _splitSelector3 = splitSelector(selectorWithRoot),
        _splitSelector4 = _slicedToArray(_splitSelector3, 2),
        root = _splitSelector4[0],
        selector = _splitSelector4[1];

    var rootNode = getRootNode(root); // check DOM when elements matching a selector are missing

    if (rootNode.querySelector(selector) === null) {
      // invoke the callback with selector
      callback([root, selector]); // disconnect observer and remove it

      removeObserver([root, selector], false);
    }
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function has$1(object, key) {
    return object != null && hasOwnProperty.call(object, key);
  }

  function getRootNode(root) {
    var _doc$querySelector;

    return root ? (_doc$querySelector = doc.querySelector(root)) !== null && _doc$querySelector !== void 0 ? _doc$querySelector : doc : doc;
  }

  function safeSelector(selector) {
    return Array.isArray(selector) ? selector.join(rootSeparator) : selector;
  }

  function splitSelector(selector) {
    var selectors = Array.isArray(selector) ? selector : String(selector).split(rootSeparator);
    return selectors.length < 2 ? [null, selectors[0]] : selectors;
  }

  function addObserver(observer, fullSelector, inserted) {
    var storage = inserted ? observers.inserted : observers.removed;
    var selector = safeSelector(fullSelector);
    if (has$1(storage, selector)) removeObserver(selector, inserted);
    storage[selector] = observer;
  }

  function removeObserver(fullSelector, inserted) {
    var storage = inserted ? observers.inserted : observers.removed;
    var selector = safeSelector(fullSelector);
    var observer = storage[selector];

    if (observer) {
      observer.disconnect();
      delete storage[selector];
    }
  }

  // WordPress dependencies
  var _lodash$8 = lodash,
      forEach$2 = _lodash$8.forEach,
      isString = _lodash$8.isString; // Internal dependencies
  var enableDebug$3 = getExternalData('debug.raw_helpers', false);
  var debug$3 = getDebug(enableDebug$3);
  var rawElements = {
    sitename: ['.interface-interface-skeleton__actions', '.editor-post-publish-panel__prepublish .components-site-name']
  }; // Replace RAW elements with content in selected language ---------------------]

  function replaceRawElements() {
    forEach$2(rawElements, function (selectors, element) {
      var _ref = isString(selectors) ? [null, selectors] : selectors,
          _ref2 = _slicedToArray(_ref, 2),
          root = _ref2[0],
          selector = _ref2[1];

      attachInsertedHooks(element, root, selector);
    });
  }

  function attachInsertedHooks(element, root, selector) {
    whenNodeInserted(root, selector, function (node) {
      var replaced = false;
      var value = node.innerHTML;

      if (hasRawBlocks(value)) {
        var editorLang = getLang();
        var shouldBeValue = getLangContent(value, editorLang);
        node.innerHTML = shouldBeValue !== null && shouldBeValue !== void 0 ? shouldBeValue : value;
        replaced = true;
      }

      debug$3.info("-^node {?inserted} for \"{".concat(element, "}\" - RAW {").concat(replaced ? '*replaced' : '!not found', "}"));
    });
  }

  // WordPress dependencies
  var _lodash$7 = lodash,
      isEmpty$2 = _lodash$7.isEmpty,
      forEach$1 = _lodash$7.forEach,
      castArray = _lodash$7.castArray; // Internal dependencies
  var supportSession = getExternalData('session', false);
  var sessionLang = supportSession ? getSessionLang() : null;
  var enableDebug$2 = getExternalData('debug.raw_helpers', false);
  var debug$2 = getDebug(enableDebug$2); // helpers for RAW attributes -------------------------------------------------]
  // set the initial values for RAW attributes
  // NB! set them only for the first time when values in 'store' are undefined
  // all subsequent calls should be ignored - it's necessary as the document editing panel
  // will be mounted and unmounted every time when switching to blocks editing
  // NB! for the first time (when values are undefined) also synchronize the displayed value with the current language
  // since the current language may differ from the server language if the 'session' support is active

  function setRawAttributes() {
    var rootLangSetter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var initAttributes = getRaw('title') === undefined;
    forEach$1(supportedKeys, function (attr) {
      var value = getRaw(attr);

      if (value === undefined) {
        value = initEditedAttribute(attr, updateRaw);
        debug$2.info("-^{?init} RAW for [".concat(attr, "]"), value);
        if (attr === 'title' && value === 'Auto Draft') value = '';
        setRaw(attr, value);
      }
    }); // do only once - when initializing the RAW store

    if (initAttributes) {
      var syncWasCalled = false;
      var editorLang = getLang(); // sync language with 'sessionLang'

      if (sessionLang && rootLangSetter) {
        debug$2.info("-^{#lang check} session/editor [".concat(sessionLang, "/").concat(editorLang, "]"));

        if (sessionLang !== editorLang) {
          rootLangSetter(sessionLang);
          syncWasCalled = true;
        }
      } // if not yet called 'rootLangSetter' - call with 'withoutOriginator' is true
      // this will lead to the regular blocks saved with another language
      // will be synchronized with the current language of the editor


      if (!syncWasCalled) rootLangSetter(editorLang, true); // set element observers that require RAW replacement

      replaceRawElements();
    }
  } // select content for the language from the RAW value and update 'Entity'
  // (if 'onlyAtts' is not null - select content for these attributes only)

  function switchRawAttributes(lang) {
    var onlyAtts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var editorLang = lang !== null && lang !== void 0 ? lang : getLang();
    var attributes = getEntityAttributes(onlyAtts === null ? null : castArray(onlyAtts));
    var edits = {};
    forEach$1(attributes, function (value, attr) {
      var rawValue = getRaw(attr);

      if (rawValue !== undefined) {
        var shouldBeValue = getLangContent(rawValue, editorLang);

        if (value !== shouldBeValue) {
          edits[attr] = shouldBeValue;
          debug$2.info("-^{switch} RAW [".concat(attr, "] for lang {").concat(editorLang, "}"), shouldBeValue);
        }
      }
    });
    updateEntityAttributes(edits);
  } // copy content for the language from the RAW value and update 'Entity'
  // (if 'overwrite' is true - then overwrite the current value, otherwise replace only empty values)

  function copyRawAttributes(lang) {
    var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var attributes = getEntityAttributes(null);
    var edits = {};
    forEach$1(attributes, function (value, attr) {
      var rawValue = getRaw(attr);

      if (rawValue !== undefined) {
        if (isEmpty$2(value) || overwrite) {
          var copyValue = getLangContent(rawValue, lang);
          edits[attr] = copyValue;
          debug$2.info("-^{copy} RAW [".concat(attr, "] from lang {").concat(lang, "}"), copyValue);
        }
      }
    });
    updateEntityAttributes(edits);
  } // because the document editing panel will be mounted and unmounted every time when switching to blocks editing
  // we register the root hook only once and do not remove it on unmounting ('addHook' has check)

  function registerRootUpdater(rootId) {
    addHook(rootId, switchRawAttributes);
  }

  // WordPress dependencies
  var _lodash$6 = lodash,
      isFunction = _lodash$6.isFunction,
      map$2 = _lodash$6.map,
      filter = _lodash$6.filter;
  var __$1 = wp.i18n.__;
  var _wp$components$1 = wp.components,
      Path$1 = _wp$components$1.Path,
      SVG$1 = _wp$components$1.SVG,
      Button = _wp$components$1.Button,
      Icon = _wp$components$1.Icon,
      ToggleControl = _wp$components$1.ToggleControl,
      NavigableMenu = _wp$components$1.NavigableMenu,
      MenuItem = _wp$components$1.MenuItem,
      Popover = _wp$components$1.Popover;
  var _wp$element$2 = wp.element,
      useCallback$3 = _wp$element$2.useCallback,
      useState = _wp$element$2.useState,
      useRef$1 = _wp$element$2.useRef,
      useMemo$1 = _wp$element$2.useMemo; // Zukit dependencies
  // export const withFlags = getExternalData('flags', false);

  var copyPrefix = 'components-zu-copy-control';
  var chevronUp = /*#__PURE__*/React.createElement(SVG$1, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React.createElement(Path$1, {
    d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
  }));
  var chevronDown = /*#__PURE__*/React.createElement(SVG$1, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React.createElement(Path$1, {
    d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z"
  }));

  var CopyControl = function CopyControl(_ref) {
    var _availableLanguages$l, _availableLanguages$l2;

    var lang = _ref.lang,
        options = _ref.options,
        onCopy = _ref.onCopy;

    var _useState = useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        isOverwriteAllowed = _useState2[0],
        setOverwriteAllowed = _useState2[1];

    var _useState3 = useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        isOpened = _useState4[0],
        setIsOpened = _useState4[1];

    var buttonRef = useRef$1(null); // const langCount = options.length - 1;

    var availableLanguages = filter(options, function (o) {
      return o.value !== lang;
    });

    var _useState5 = useState(0),
        _useState6 = _slicedToArray(_useState5, 2),
        langIndex = _useState6[0],
        setLangIndex = _useState6[1];

    var toLang = (_availableLanguages$l = availableLanguages[langIndex]) === null || _availableLanguages$l === void 0 ? void 0 : _availableLanguages$l.value;
    var toLabel = (_availableLanguages$l2 = availableLanguages[langIndex]) === null || _availableLanguages$l2 === void 0 ? void 0 : _availableLanguages$l2.label;
    var closeOutside = useCallback$3(function (event) {
      if (buttonRef && !buttonRef.current.contains(event.relatedTarget)) {
        setIsOpened(false);
      }
    }, []);
    var togglePopup = useCallback$3(function () {
      return setIsOpened(function (prevIsOpen) {
        return !prevIsOpen;
      });
    }, []);
    var copyValue = useCallback$3(function (fromLang) {
      if (isFunction(onCopy)) onCopy(fromLang, isOverwriteAllowed);else copyRawAttributes(fromLang, isOverwriteAllowed);
    }, [onCopy, isOverwriteAllowed]); // The menu items are practically unchanged (only if 'options' is updated)
    // and therefore we Memoize them

    var menuItems = useMemo$1(function () {
      // do nothing if no 'options'
      // if(isEmpty(options)) return [];
      // Use only the items presented in 'options' and not empty
      // const menuOptions = filter(options, o => !isEmpty(options[o.linkDestination]));
      var onChange = function onChange(index) {
        setLangIndex(index);
        setIsOpened(false);
      };

      return map$2(availableLanguages, function (option, index) {
        return /*#__PURE__*/React.createElement(MenuItem, {
          key: option.value // icon={ option.icon }
          ,
          onClick: function onClick() {
            return onChange(index);
          }
        }, option.label);
      });
    }, [availableLanguages]);
    var isDisabled = false;
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: copyPrefix
    }, /*#__PURE__*/React.createElement(Button, {
      disabled: isDisabled,
      className: "".concat(copyPrefix, "__action"),
      onClick: function onClick() {
        return copyValue(toLang);
      } // ref={ buttonRef }

    }, __$1('Copy from', 'zu-translate')), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Button, {
      disabled: isDisabled,
      className: "".concat(copyPrefix, "__lang"),
      "aria-expanded": isOpened,
      onClick: togglePopup,
      ref: buttonRef
    }, toLabel, /*#__PURE__*/React.createElement("span", {
      className: "".concat(copyPrefix, "__arrow"),
      "aria-hidden": "true"
    }, /*#__PURE__*/React.createElement(Icon, {
      icon: isOpened ? chevronUp : chevronDown
    }))), isOpened && /*#__PURE__*/React.createElement(Popover, {
      className: "".concat(copyPrefix, "__popup"),
      position: "bottom right",
      onFocusOutside: closeOutside // anchorRect={ false }

    }, /*#__PURE__*/React.createElement(NavigableMenu, {
      className: "".concat(copyPrefix, "__menu") // ref={ menuContainer }
      // onKeyDown={ manageFocusOnInput }

    }, menuItems)))), /*#__PURE__*/React.createElement(ToggleControl, {
      className: "".concat(copyPrefix, "__toggle"),
      label: __$1('Allow Overwrite', 'zu-translate'),
      checked: isOverwriteAllowed,
      onChange: function onChange() {
        return setOverwriteAllowed(!isOverwriteAllowed);
      }
    }));
  };

  var _excluded = ["title", "lang", "onClick", "onCopy", "withPanel"];
  // WordPress dependencies
  var _lodash$5 = lodash,
      map$1 = _lodash$5.map,
      pick$1 = _lodash$5.pick;
  var __ = wp.i18n.__;
  var _wp$components = wp.components,
      PanelBody = _wp$components.PanelBody,
      Path = _wp$components.Path,
      SVG = _wp$components.SVG;
  var useCallback$2 = wp.element.useCallback; // Zukit dependencies

  var _wp$zukit$components = wp.zukit.components,
      SelectItemControl = _wp$zukit$components.SelectItemControl,
      TitleIndicator = _wp$zukit$components.TitleIndicator; // Internal dependencies
  var initialOpen = getExternalData('initial', false);
  var config = getExternalData('config', []);
  var flagPath = getExternalData('location', []);
  var langOptions = map$1(config, function (data, key) {
    return {
      value: key,
      label: data.name,
      flag: data.flag
    };
  });
  var withFlags = getExternalData('flags', false);
  var langPrefix = 'components-zu-lang-control';
  var tick = /*#__PURE__*/React.createElement(SVG, {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React.createElement(Path, {
    d: "M18.3 5.6L9.9 16.9l-4.6-3.4-.9 1.2 5.8 4.3 9.3-12.6z"
  }));

  var LangIndicator = function LangIndicator(_ref) {
    var title = _ref.title,
        lang = _ref.lang,
        colored = _ref.colored;
    return /*#__PURE__*/React.createElement(TitleIndicator, {
      title: title !== null && title !== void 0 ? title : __('Language', 'zu-translate'),
      value: lang,
      colored: colored
    });
  };

  var LangControl = function LangControl(_ref2) {
    var title = _ref2.title,
        lang = _ref2.lang,
        onClick = _ref2.onClick,
        onCopy = _ref2.onCopy,
        withPanel = _ref2.withPanel,
        additionalProps = _objectWithoutProperties(_ref2, _excluded);

    var langValue = useCallback$2(function (value, label, style, more) {
      return /*#__PURE__*/React.createElement("span", {
        className: mergeClasses('__lang', {
          '__with-flags': withFlags
        }),
        style: style
      }, withFlags && /*#__PURE__*/React.createElement("img", {
        className: "__flag",
        src: more.flag ? flagPath + more.flag : emptyGif
      }), label, lang === value ? tick : null);
    }, [lang]);
    var langControl = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SelectItemControl, {
      className: langPrefix,
      options: langOptions,
      selectedItem: lang,
      onClick: onClick,
      transformValue: langValue
    }), /*#__PURE__*/React.createElement(CopyControl, {
      className: langPrefix,
      lang: lang,
      options: langOptions,
      onCopy: onCopy
    }));

    if (withPanel) {
      var titleWithIndicator = /*#__PURE__*/React.createElement(LangIndicator, {
        title: title,
        lang: lang
      });
      var panelProps = pick$1(additionalProps, ['buttonProps', 'className', 'icon', 'opened', 'scrollAfterOpen', 'onToggle']);
      return /*#__PURE__*/React.createElement(PanelBody, _extends({
        title: titleWithIndicator,
        initialOpen: initialOpen
      }, panelProps), langControl);
    }

    return langControl;
  };

  LangControl.Panel = function (props) {
    return /*#__PURE__*/React.createElement(LangControl, _extends({
      withPanel: true
    }, props));
  };

  LangControl.Indicator = LangIndicator;

  // WordPress dependencies
  var _wp$element$1 = wp.element,
      useCallback$1 = _wp$element$1.useCallback,
      useEffect$1 = _wp$element$1.useEffect;
  wp.components.Button; // Zukit dependencies

  var withPlugin = wp.zukit.plugins.withPlugin;
  var useForceUpdater$1 = wp.zukit.data.useForceUpdater; // Internal dependencies

  var LangControlSetting = function LangControlSetting(_ref) {
    var forceUpdateParent = _ref.forceUpdate;
    var forceUpdate = useForceUpdater$1(); // in the hook is checked if the language has changed, then we call 'switchRawAttributes'

    var editorLang = useOnLangChange(rootClientId, switchRawAttributes); // switch the language, call the update of the component and its parent -
    // since the update does not happen by itself because we do not store the language value in the component state
    // (changing the content of the element to the value corresponding to the new language will occur in 'useOnLangChange' hook)

    var setLanguage = useCallback$1(function (value, withoutMyself) {
      changeLang(value);
      forceUpdate();
      forceUpdateParent(); // a special case when we need to synchronize blocks when initialized
      // in this situation, the 'withoutMyself' will be true

      syncBlocks(rootClientId, withoutMyself); // 'forceUpdate' and 'forceUpdateParent' never change
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useEffect$1(function () {
      // register 'rootUpdater' for subsequent language synchronization
      registerRootUpdater(rootClientId); // set the initial RAW attributes on mounting the component

      setRawAttributes(setLanguage); // 'setLanguage' never changes
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var testButton = false;
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(LangControl, {
      lang: editorLang,
      onClick: setLanguage
    }), testButton );
  };

  var pluginProps = _objectSpread2(_objectSpread2({}, metadata), {}, {
    title: LangControl.Indicator,
    titleProps: function titleProps() {
      return {
        lang: getLang()
      };
    }
  });

  var render = withPlugin(pluginProps)(LangControlSetting); // NOTE: All experiments left here --------------------------------------------]
  // function collectAllRelatedBlocks(blocks) {
  // 	return reduce(blocks, (collected, {clientId, innerBlocks, attributes}) => {
  // 		if(has(attributes, 'qtxLang')) collected.push(clientId);
  // 		if(innerBlocks.length) {
  // 			const innerIds = collectAllRelatedBlocks(innerBlocks);
  // 			collected.push(...innerIds);
  // 		}
  // 		return collected;
  // 	}, []);
  // }
  //
  // function switchAllRelatedBlocks(lang, getBlocks, updateBlockAttributes, clientId = null) {
  // 	const allBlocks = getBlocks();
  // 	const blockIds = collectAllRelatedBlocks(allBlocks);
  // 	Zubug.data({ allBlocks, blockIds });
  //
  // 	blockIds.forEach(blockClientId => {
  // 		// do not update own attributes
  // 		if(blockClientId !== clientId) {
  // 			updateBlockAttributes(blockClientId, { qtxLang: lang } );
  // 		}
  // 	});
  // }
  // export default compose([
  // 	withPluginNoMeta(metadata),
  // 	withSelect(select => {
  // 		return { getBlocks: select('core/block-editor').getBlocks };
  // 	}),
  // 	withDispatch(dispatch => {
  // 		// const { updateBlockAttributes } = dispatch('core/block-editor');
  // 		return { updateBlockAttributes: dispatch('core/block-editor').updateBlockAttributes };
  // 	}),
  // ])(LangControlSetting);

  // Internal dependencies
  var name = metadata.name,
      title = metadata.title;
  var settings = {
    title: title,
    render: render
  };

  var plugin = /*#__PURE__*/Object.freeze({
    __proto__: null,
    metadata: metadata,
    name: name,
    settings: settings
  });

  // WordPress dependencies
  var _lodash$4 = lodash,
      isEmpty$1 = _lodash$4.isEmpty,
      includes$1 = _lodash$4.includes,
      map = _lodash$4.map,
      transform = _lodash$4.transform,
      set$2 = _lodash$4.set;
  var createHigherOrderComponent = wp.compose.createHigherOrderComponent;
  var InspectorControls = wp.blockEditor.InspectorControls;
  var _wp$element = wp.element,
      useEffect = _wp$element.useEffect,
      useCallback = _wp$element.useCallback,
      useRef = _wp$element.useRef,
      useMemo = _wp$element.useMemo; // Zukit dependencies

  var useForceUpdater = wp.zukit.data.useForceUpdater; // Internal dependencies
  var activateSync = getExternalData('sync', false);
  var enableDebug$1 = getExternalData('debug.edit_lang', false);
  var debug$1 = getDebug(enableDebug$1);

  var BlockEditLang = function BlockEditLang(props) {
    var name = props.name,
        clientId = props.clientId,
        setAttributes = props.setAttributes,
        attributes = props.attributes;
    var qtxRaw = attributes.qtxRaw,
        qtxLang = attributes.qtxLang; // store 'qtxRaw' on the reference since its update occurs in 'useEffect'

    var rawRef = useRef(null);

    if (rawRef.current === null) {
      rawRef.current = {
        raw: qtxRaw,
        id: clientId
      };
      debug$1.infoWithId(clientId, "-?Initiated with language {".concat(qtxLang, "}"));
    } // create a list of attributes and an array of their values ('translatedAtts' is string - see 'utils.js')


    var _getTranslated = getTranslated(name, attributes),
        _getTranslated2 = _slicedToArray(_getTranslated, 2),
        translatedAtts = _getTranslated2[0],
        translatedValues = _getTranslated2[1]; // callback for replacing the values of all 'translated' attributes for the required language


    var replaceContent = useCallback(function (lang) {
      var prevLang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // if sync is not activated and 'prevLang' is false - the call was from the hook
      // and in this mode we ignore the change of language
      if (!activateSync && !prevLang) return;
      var _rawRef$current = rawRef.current,
          raw = _rawRef$current.raw,
          id = _rawRef$current.id;

      if (lang !== prevLang) {
        var atts = switchContent(raw, lang, translatedAtts);
        debug$1.infoWithId(id, "-^{+switching} RAW [".concat(translatedAtts, "] for lang {").concat(lang, "}"), atts);
        setAttributes(_objectSpread2({
          qtxLang: lang
        }, atts));
      } else {
        debug$1.infoWithId(id, "-^{#skip switching} RAW [".concat(translatedAtts, "]"), {
          lang: lang,
          prevLang: prevLang,
          activateSync: activateSync
        });
      }

      syncCompleted(id);
    }, [translatedAtts, setAttributes]);
    var forceUpdate = useForceUpdater(); // in the hook is checked if the language has changed, then we call 'replaceContent'

    var editorLang = useOnLangChange(clientId, replaceContent, qtxLang); // register 'forceUpdate' for subsequent language synchronization

    useLangHook(clientId, forceUpdate);
    var onChangeLang = useCallback(function (lang) {
      var id = rawRef.current.id;

      if (activateSync) {
        changeLang(lang);
        forceUpdate();
        syncBlocks(id);
      } else {
        syncBlocks(id, true);
        replaceContent(lang, qtxLang);
      }

      debug$1.infoWithId(id, "-^Language switched [".concat(qtxLang, " -> ").concat(lang, "]"));
    }, [forceUpdate, replaceContent, qtxLang]);
    var onCopyLang = useCallback(function (fromLang, overwrite) {
      var _rawRef$current2 = rawRef.current,
          raw = _rawRef$current2.raw,
          id = _rawRef$current2.id;
      var atts = splitAtts(translatedAtts);
      var update = switchContent(raw, fromLang, translatedAtts); // if the value cannot be copied, then replace the value with 'undefined', then it will be skipped when updating 'raw'

      var values = map(atts, function (val, index) {
        return isEmpty$1(translatedValues[index]) || overwrite ? update[val] : undefined;
      });
      var updatedRaw = updateRawContent(raw, qtxLang, values);

      if (updatedRaw !== raw) {
        // leave only those attributes that were copied (see above)
        var updateAtts = transform(values, function (acc, val, index) {
          return val !== undefined ? set$2(acc, atts[index], val) : false;
        }, {});
        rawRef.current.raw = updatedRaw;
        setAttributes(_objectSpread2({
          qtxRaw: updatedRaw
        }, updateAtts));
        debug$1.infoWithId(id, "-^Content copied from [".concat(fromLang, "]"), {
          updateAtts: updateAtts,
          updatedRaw: updatedRaw
        });
      }
    }, [qtxLang, translatedAtts, translatedValues, setAttributes]); // synchronize, create RAW if does not exist and maybe fix it - on mounting only

    useEffect(function () {
      // if RAW does not exist - create it
      if (!hasRaw(rawRef)) {
        var _createRawContent = createRawContent(editorLang, translatedValues, translatedAtts),
            _createRawContent2 = _slicedToArray(_createRawContent, 2),
            raw = _createRawContent2[0],
            update = _createRawContent2[1];

        rawRef.current.raw = raw;
        setAttributes(_objectSpread2({
          qtxLang: editorLang,
          qtxRaw: raw
        }, update));
        debug$1.infoWithId(rawRef.current.id, '-?Raw {created} on mounting', {
          qtxLang: qtxLang,
          raw: raw,
          update: update,
          translatedValues: translatedValues,
          translatedAtts: translatedAtts
        });
      } else {
        // fix if RAW was created for wrong amount of attributes
        var _rawRef$current3 = rawRef.current,
            _raw = _rawRef$current3.raw,
            id = _rawRef$current3.id;
        var fixedRaw = maybeFixRawContent(_raw, editorLang, translatedValues);
        var wasFixed = fixedRaw !== false;
        debug$1.infoWithId(id, "-^Raw {".concat(wasFixed ? '!fixed' : '*existed', "} on mounting"), {
          raw: _raw,
          fixedRaw: wasFixed ? fixedRaw : null,
          translatedValues: translatedValues,
          translatedAtts: translatedAtts
        });
        if (fixedRaw !== false) rawRef.current.raw = fixedRaw;
      } // eslint-disable-next-line react-hooks/exhaustive-deps

    }, []); // after each change in one of the attributes that require the translation, we update 'qtxRaw'

    useEffect(function () {
      if (hasRaw(rawRef)) {
        var raw = rawRef.current.raw;
        var updatedRaw = updateRawContent(raw, qtxLang, translatedValues);

        if (updatedRaw !== raw) {
          rawRef.current.raw = updatedRaw;
          setAttributes({
            qtxRaw: updatedRaw
          });
          debug$1.infoWithId(rawRef.current.id, '-^Raw {updated}', {
            updatedRaw: updatedRaw,
            translatedValues: translatedValues
          });
        }
      } // we used a spread element in the dependency array -> we can't statically verify the correct dependencies
      // eslint-disable-next-line react-hooks/exhaustive-deps

    }, [].concat(_toConsumableArray(translatedValues), [qtxLang, setAttributes]));
    return useMemo(function () {
      return /*#__PURE__*/React.createElement(InspectorControls, null, /*#__PURE__*/React.createElement(LangControl.Panel, {
        lang: qtxLang,
        onClick: onChangeLang,
        onCopy: onCopyLang
      }));
    }, [qtxLang, onChangeLang, onCopyLang]);
  }; // HOC in which we add a language editing panel if the block fits our requirements


  var withRawEditControl = createHigherOrderComponent(function (BlockEdit) {
    return function (props) {
      var name = props.name,
          clientId = props.clientId;
      var editorIds = getEditorBlocks(); // 'getEditorBlocks' returns all block client IDs in the editor, check if our block is in this list
      // NOTE: sometimes the blocks of those types that we support are created, but these blocks are not edited in the editor -
      // for example, blocks for visual preview of the editable block

      var isEditableBlock = includes$1(editorIds, clientId);
      if (!isEditableBlock) debug$1.infoWithId(clientId, "-^Block [".concat(name, "] was skipped"), {
        editableBlocks: editorIds
      });else debug$1.infoWithId(clientId, "-^Block [".concat(name, "] is editable and {").concat(isSupported(name) ? '*is' : '!is not', " supported}"));
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(BlockEdit, props), isSupported(name) && isEditableBlock && /*#__PURE__*/React.createElement(BlockEditLang, props));
    };
  }, 'withRawEditControl');

  // WordPress dependencies
  var _lodash$3 = lodash,
      isNil = _lodash$3.isNil,
      assign = _lodash$3.assign,
      has = _lodash$3.has;
  var addFilter = wp.hooks.addFilter; // const { useEffect, useCallback } = wp.element; // cloneElement, useState, useEffect, useLayoutEffect

  function addRawAttribute(settings, name) {
    if (!isNil(settings.attributes)) {
      if (isSupported(name)) {
        // maybe we have already added attributes to this block?
        // sometimes blocks are registered several times (who knows why?)
        if (!has(settings, 'attributes.qtxRaw')) {
          settings.attributes = assign({}, settings.attributes, {
            qtxRaw: {
              type: 'string'
            },
            qtxLang: {
              type: 'string'
            }
          });
        }
      }
    }

    return settings;
  }

  addFilter('blocks.registerBlockType', 'zu/translate', addRawAttribute);
  addFilter('editor.BlockEdit', 'zu/translate', withRawEditControl); // NOTE: All experiments left here --------------------------------------------]
  // const { isSavingPost } = select('core/editor');
  // let postSaved = true;
  //
  // subscribe(() => {
  //     if(isSavingPost()) {
  // 		postSaved = false;
  // 		Zubug.info('{isSavingPost}');
  //     } else {
  // 		if(!postSaved) {
  //             Zubug.info('~Post Saved~');
  //             postSaved = true;
  //         }
  //     }
  // });
  // // Collect information on registered blocks
  // const filterBlocks = (settings, name) => {
  //     console.log(settings.name, name);
  // 	if(settings.name === 'core/button') console.log('settings', settings);
  //     // we need to pass along the settings object
  //     // even if we haven't modified them!
  //     return settings;
  // }
  //
  // addFilter(
  //     'blocks.registerBlockType',
  //     'zu/test',
  //     filterBlocks
  // );
  // function applyExtraProps(extraProps, blockType, attributes) {
  // 	const {
  // 		content,
  // 		rawContent,
  // 		lang,
  // 	} = attributes;
  // 	if(isSupported(blockType?.name)) {
  // 		Zubug.data({ extraProps, blockType, attributes });
  // 	}
  //
  // 	const blocks = qtranxj_split(rawContent);
  // 	blocks[lang] = content;
  // 	const newLang = lang === 'en' ? 'ru' : 'en';
  // 	Zubug.data({ lang, content,  blocks });
  // 	extraProps.className join([...map(blocks, (text, l) => `[:${l}]${text}`), '[:]'], '')
  //
  // 	if(typeof hideOnMobile !== 'undefined' && hideOnMobile) {
  // 		extraProps.className = extraProps.className + ' hide-on-mobile';
  // 	}
  // 	return extraProps;
  // }
  // addFilter('blocks.getSaveContent.extraProps', 'zu/paragraph', applyExtraProps);
  // function getBlockAttributes(attributes, blockType, param3, param4) {
  // 	if(isSupported(blockType?.name)) {
  // 		const { content, rawContent, lang } = attributes;
  // 		const translated = rawContent ? getLangContent(rawContent, lang) : content;
  // 		attributes.content = translated;
  // 		Zubug.data({ attributes, blockType, param3, param4 });
  // 		return attributes;
  // 	}
  // 	return attributes;
  // }
  // addFilter('blocks.getBlockAttributes', 'zu/paragraph', getBlockAttributes);
  // function getSaveElement(elem, blockType, attributes) {
  // 	const blockName = blockType?.name;
  // 	if(isSupported(blockName)) {
  // 		// Zubug.info('called');
  // 		if(attributes.isXT) {
  // 			// const fallback = () => elem;
  // 			const { rawContent } = attributes;
  // 			const isEdit = !!rawContent;
  // 			// // const save = get(blockSave, blockName) ?? fallback;
  // 			Zubug.info(isSavingPost() ? '{isSavingPost}' : 'update?');
  // 			if(isEdit) {
  // 				attributes.content = rawContent;
  // 				// attributes.rawContent = undefined;
  // 				const newEl = cloneElement(elem, { attributes });
  // 				Zubug.data({ content: attributes.content, rawContent: attributes.rawContent }, 'new Element');
  // 				return newEl;
  // 			}
  // 		}
  // 	}
  // 	return elem;
  // }
  // addFilter('blocks.getSaveElement', 'zu/paragraph', getSaveElement);

  // WordPress dependencies
  var _lodash$2 = lodash,
      isEmpty = _lodash$2.isEmpty,
      isEqual = _lodash$2.isEqual,
      isArray = _lodash$2.isArray,
      forEach = _lodash$2.forEach,
      get$1 = _lodash$2.get,
      set$1 = _lodash$2.set,
      keys = _lodash$2.keys,
      pick = _lodash$2.pick,
      merge = _lodash$2.merge,
      difference = _lodash$2.difference,
      includes = _lodash$2.includes;
  var sprintf = wp.i18n.sprintf;
  var _wp$data$1 = wp.data,
      subscribe$1 = _wp$data$1.subscribe,
      select$1 = _wp$data$1.select; // Internal dependencies

  var _select$1 = select$1('core/editor'),
      isSavingPost = _select$1.isSavingPost,
      isEditedPostDirty = _select$1.isEditedPostDirty,
      isCurrentPostPublished = _select$1.isCurrentPostPublished,
      getCurrentPostType = _select$1.getCurrentPostType,
      getCurrentPostId$1 = _select$1.getCurrentPostId;

  var _select2 = select$1('core/block-editor'),
      getBlocks = _select2.getBlocks;

  var _select3 = select$1('core'),
      getEntityRecordNonTransientEdits = _select3.getEntityRecordNonTransientEdits,
      getEditedEntityRecord = _select3.getEditedEntityRecord;

  var enableDebug = getExternalData('debug.explorer', false);
  var debug = getDebug(enableDebug); // Explore changes for debug/research (green/red) -----------------------------]

  var reported = {
    isDirty: null,
    blocks: null,
    edits: null,
    postSaved: true
  };

  if (enableDebug) {
    initExplorer();
    runExplorer();
    watchSavingPost();
  }

  function initExplorer() {
    var unsubscribe = subscribe$1(function () {
      var postId = getCurrentPostId$1();
      var isDirty = isEditedPostDirty();

      if (postId && reported.blocks === null) {
        debugPostStatus(isDirty, {
          postId: postId,
          isPublished: isCurrentPostPublished()
        });
        reported.isDirty = isDirty;
      }

      if (postId && isEmpty(reported.blocks)) {
        reported.blocks = getBlocks();

        if (!isEmpty(reported.blocks)) {
          var _getEdits = getEdits(),
              edits = _getEdits.edits;

          reported.edits = edits;
          unsubscribe();
        }
      }
    });
  }

  function runExplorer() {
    subscribe$1(function () {
      if (isEditedPostDirty()) {
        var dirtyData = {};
        var newBlocks = getBlocks();

        if (reported.blocks !== newBlocks) {
          var changes = {};
          forEach(newBlocks, function (next, index) {
            var prev = reported.blocks[index];

            if (next !== prev) {
              var changed = changedKeys(next, prev);

              if (includes(changed.updated, 'attributes')) {
                var updateAtts = changedKeys(next.attributes, prev.attributes);
                var pickAtts = [].concat(_toConsumableArray(updateAtts.updated), _toConsumableArray(updateAtts.added), _toConsumableArray(updateAtts.removed));
                changes[next.clientId] = {
                  name: next.name,
                  changed: changed,
                  attributes: updateAtts,
                  picked: pickAtts,
                  was: pick(prev.attributes, pickAtts),
                  now: pick(next.attributes, pickAtts)
                };
              } else {
                changes[next.clientId] = {
                  name: next.name,
                  changed: changed
                };
              }
            }
          });
          dirtyData.blocks = changes;
          reported.blocks = newBlocks;
        }

        var _getEdits2 = getEdits(),
            edits = _getEdits2.edits,
            entity = _getEdits2.entity;

        var msissingAtts = difference(reported.edits, edits);

        if (!isEqual(reported.edits, edits)) {
          forEach(merge({}, edits, msissingAtts), function (attr) {
            var _entity$attr;

            // 'content' has already been processed in the 'blocks' loop
            if (attr !== 'content') set$1(dirtyData, ['edits', attr], (_entity$attr = entity[attr]) !== null && _entity$attr !== void 0 ? _entity$attr : '?');
          });
          reported.edits = edits;
        }

        if (!isEmpty(dirtyData)) debugPostStatus(true, dirtyData);
        reported.isDirty = true;
      } else if (reported.isDirty) {
        reported.isDirty = false;
        debugPostStatus(false, {
          postId: getCurrentPostId$1(),
          isPublished: isCurrentPostPublished()
        });
      }
    });
  }

  function watchSavingPost() {
    subscribe$1(function () {
      if (reported.postSaved && isSavingPost()) {
        reported.postSaved = false;
        debug.logGroup('{+Saving Post...}', getEdits());
      } else if (!reported.postSaved) {
        debug.info('{*Post Saved}');
        reported.postSaved = true;
      }
    });
  } // Internal debug helpers -----------------------------------------------------]


  function getEdits() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var recordId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var postType = name !== null && name !== void 0 ? name : getCurrentPostType();
    var postId = recordId !== null && recordId !== void 0 ? recordId : getCurrentPostId$1();
    return {
      edits: keys(getEntityRecordNonTransientEdits('postType', postType, postId)),
      entity: getEditedEntityRecord('postType', postType, postId)
    };
  }

  function changedKeys(next, prev) {
    var updated = [];
    forEach(next, function (val, key) {
      if (prev && prev[key] !== val) {
        updated.push(key);
      }
    });
    var nextKeys = keys(next);
    var prevKeys = keys(prev);
    var added = difference(nextKeys, prevKeys);
    var removed = difference(prevKeys, nextKeys);
    return {
      // 'added' keys will also be included in 'updated', so we exclude them
      updated: difference(updated, added),
      added: added,
      removed: removed
    };
  }

  function debugPostStatus(isDirty, params) {
    if (enableDebug) {
      var isPublished = params.isPublished,
          postId = params.postId,
          blocks = params.blocks,
          edits = params.edits;

      if (postId) {
        debug.info(sprintf('-%sPost #%d [%s] and editing state is {%s}', isDirty ? '!' : '*', postId, isPublished ? 'published' : 'not published', isDirty ? 'dirty' : 'clean'));
      } else {
        var changedAtts = keys(edits);
        var changedBlocks = keys(blocks);

        if (changedAtts.length || changedBlocks.length) {
          debug.logGroup("!Post is {dirty} - {?see details}");
        }

        forEach(edits, function (value, key) {
          var id = "+".concat(key);
          debugChanged(id, 'entity', 'updated', value);
        });
        forEach(blocks, function (value, key) {
          var name = value.name,
              changed = value.changed,
              attributes = value.attributes,
              picked = value.picked,
              was = value.was,
              now = value.now;
          var id = "+".concat(name, " : ").concat(debug.shortenId(key));
          id = debugChanged(id, 'props', 'updated', changed);
          id = debugChanged(id, 'props', 'added', changed);
          id = debugChanged(id, 'props', 'removed', changed);

          if (attributes) {
            debugChanged(id, 'attributes', 'updated', attributes);
            debugChanged(id, 'attributes', 'added', attributes);
            debugChanged(id, 'attributes', 'removed', attributes);
            if (was || now) debugWasNow(id, picked, was, now);
          }
        });
        debug.logGroup('<');
      }
    }
  }

  function debugChanged(id, name, key, value) {
    var data = get$1(value, key, value);

    if (!isEmpty(data)) {
      debug.logGroup(id, sprintf('%s %s [%s]', key, name, isArray(data) ? data.join(', ') : data));
      return id.startsWith('-') ? id : id.replace(/^[+]/, '-');
    }

    return id;
  }

  function debugWasNow(id, atts, was, now) {
    var isSingleKey = atts.length === 1;
    var key = isSingleKey ? atts[0] : atts.join(', ');

    if (isSingleKey) {
      debug.logGroup(id, ["[".concat(key, "]"), '  {+was}  ', was[key], '  {*now}  ', now[key]]);
    } else {
      debug.logGroup(id, ["[".concat(key, "]"), '  {+values were}  ', was]);
      debug.logGroup(id, ["[".concat(key, "]"), '  {*values are now}  ', now]);
    }
  }

  // WordPress dependencies
  var _lodash$1 = lodash,
      get = _lodash$1.get,
      set = _lodash$1.set,
      once = _lodash$1.once;
  var _wp$data = wp.data,
      subscribe = _wp$data.subscribe,
      select = _wp$data.select;

  var _select = select('core/editor'),
      getCurrentPostId = _select.getCurrentPostId,
      isEditedPostNew = _select.isEditedPostNew;

  function resetPostEditorAutosave() {
    var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ZUKIT';
    var resetKey = 'resetAutosave'; // may have already been initiated in another plugin or theme

    if (!get(wp, ['zukit', resetKey])) {
      set(wp, ['zukit', resetKey], true);
      var unsubscribe = subscribe(function () {
        var postId = getCurrentPostId();

        if (postId) {
          resetLocalBackup(postId);
          unsubscribe();
        }
      });

      var resetLocalBackup = function resetLocalBackup(postId) {
        if (hasSessionStorageSupport()) {
          var isPostNew = isEditedPostNew();
          var localAutosave = localAutosaveGet(postId, isPostNew);
          if (!localAutosave) return;

          try {
            localAutosave = JSON.parse(localAutosave);
          } catch (error) {
            // not usable if it can't be parsed.
            return;
          } // if 'localAutosave' was found, it can be safely ejected from storage.


          localAutosaveClear(postId, isPostNew);
          window.console.warn("".concat(origin.toUpperCase(), ": The backup of the post [").concat(postId, "] in your browser was removed"));
        }
      };
    }
  } // Function which returns true if the current environment supports browser
  // sessionStorage, or false otherwise.

  var hasSessionStorageSupport = once(function () {
    try {
      // Private Browsing in Safari 10 and earlier will throw an error when
      // attempting to set into sessionStorage. The test here is intentional in
      // causing a thrown error as condition bailing from local autosave.
      window.sessionStorage.setItem('__wpEditorTestSessionStorage', '');
      window.sessionStorage.removeItem('__wpEditorTestSessionStorage');
      return true;
    } catch (error) {
      return false;
    }
  }); // Function returning a sessionStorage key to set or retrieve a given post's
  // automatic session backup.

  function postKey(postId, isPostNew) {
    return "wp-autosave-block-editor-post-".concat(isPostNew ? 'auto-draft' : postId);
  }

  function localAutosaveGet(postId, isPostNew) {
    return window.sessionStorage.getItem(postKey(postId, isPostNew));
  }

  function localAutosaveClear(postId, isPostNew) {
    window.sessionStorage.removeItem(postKey(postId, isPostNew));
  } // resetPostEditorAutosave();

  // WordPress dependencies
  var _lodash = lodash,
      defaults = _lodash.defaults;
  var registerPlugin = wp.plugins.registerPlugin; // Internal dependencies

  if (getExternalData('nobackups', false)) {
    resetPostEditorAutosave('Zu Translate');
  } //  Register Plugins ----------------------------------------------------------]


  function registerPlugins() {
    [plugin // status,
    ].forEach(function (sidebar) {
      if (!sidebar) return;
      var name = sidebar.name,
          settings = sidebar.settings; // we need to pass {icon: false} if the attribute is missed to avoid rendering the default icon

      registerPlugin(name, defaults(settings, {
        icon: false
      }));
    });
  }
  registerPlugins();

  exports.registerPlugins = registerPlugins;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
//# sourceMappingURL=zutranslate-blocks.min.js.map
